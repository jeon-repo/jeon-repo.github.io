[
  
  {
    "title"    : "[백준 4396번] 지뢰 찾기",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/09/05/%EB%B0%B1%EC%A4%80-4396%EB%B2%88.html",
    "date"     : "September 5, 2021",
    "excerpt"  : "\n\n백준 “지뢰 찾기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n지뢰찾기는 n × n 격자 위에서 이루어진다. m개의 지뢰가 각각 서로 다른 격자 위에 숨겨져 있다. 플레이어는 격자판의 어느 지점을 건드리기를 계속한다. 지뢰가 있는 지점을 건드리면 플레이어가 진다. 지뢰가 없는 지점을 건드리면, 그곳의 상하좌우 혹은 대각선으로 인접한 8개의 칸에 지뢰가 몇 개 있는지 알려주는 0과 8 사이의 숫자가 ...",
  "content"  : "\n\n백준 “지뢰 찾기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n지뢰찾기는 n × n 격자 위에서 이루어진다. m개의 지뢰가 각각 서로 다른 격자 위에 숨겨져 있다. 플레이어는 격자판의 어느 지점을 건드리기를 계속한다. 지뢰가 있는 지점을 건드리면 플레이어가 진다. 지뢰가 없는 지점을 건드리면, 그곳의 상하좌우 혹은 대각선으로 인접한 8개의 칸에 지뢰가 몇 개 있는지 알려주는 0과 8 사이의 숫자가 나타난다. 완전히 플레이되지 않은 게임에서 일련의 동작이 아래에 나타나 있다.\n\n\n\n\n\n\n\n여기서, n은 8이고, m은 10이며, 빈 칸은 숫자 0을 의미하고, 올라가 있는 칸은 아직 플레이되지 않은 위치이며, 별표 모양(*)과 닮은 그림은 지뢰를 의미한다. 맨 왼쪽의 그림은 일부만이 플레이된 게임을 나타낸다. 첫 번째 그림에서 두 번째 그림으로 오면서, 플레이어는 두 번의 이동을 시행해서, 두 번 다 안전한 곳을 골랐다. 세 번째 그림을 볼 때 플레이어는 운이 썩 좋지는 않았다. 지뢰가 있는 곳을 골라서 게임에서 졌다. 플레이어는 m개의 열리지 않은 칸을 남길 때까지 계속해서 안전한 곳을 고르면 이긴다. 그 m개의 칸은 반드시 지뢰이다.\n\n당신이 할 일은 일부가 플레이된 게임의 정보를 읽어 해당하는 격자를 출력하는 것이다.\n\n입력\n\n첫 번째 줄에는 10보다 작거나 같은 양의 정수 n이 입력된다. 다음 n개의 줄은 지뢰의 위치를 나타낸다. 각각의 줄은 n개의 문자를 사용하여 한 행을 나타낸다. 온점(.)은 지뢰가 없는 지점이며 별표(*)는 지뢰가 있는 지점이다. 다음 n개의 줄에는 길이가 n인 문자열이 입력된다. 이미 열린 칸은 영소문자 x로, 열리지 않은 칸은 온점(.)으로 표시된다. 예제 입력은 문제 설명에서의 가운데 그림과 상응한다.\n\n출력\n\n출력은 각각의 위치가 정확하게 채워진 판을 표현해야 한다. 지뢰가 없으면서 열린 칸에는 0과 8 사이의 숫자가 있어야 한다. 지뢰가 있는 칸이 열렸다면 지뢰가 있는 모든 칸이 별표(*)로 표시되어야 한다. 다른 모든 지점은 온점(.)이어야 한다.\n\n예제 입력 1\n\n8\n...**..*\n......*.\n....*...\n........\n........\n.....*..\n...**.*.\n.....*..\nxxx.....\nxxxx....\nxxxx....\nxxxxx...\nxxxxx...\nxxxxx...\nxxx.....\nxxxxx...\n\n\n예제 출력 1\n\n001.....\n0013....\n0001....\n00011...\n00001...\n00123...\n001.....\n00123...\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  구현 문제\n  체크된 곳과 지뢰의 좌표만 따로 저장\n  체크된 곳 주변 지뢰 탐색\n  지뢰가 폭발하면 모든 지뢰 표시\n  체크된 곳은 근처 지뢰 수를 표시\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport sys\ninput = sys.stdin.readline\n\ndef solution():\n    n = int(input())\n    board = [input().strip() for _ in range(n)]\n    open_board = [list(input().strip()) for _ in range(n)]\n\n    # 체크된 곳의 좌표와 근처 지뢰 수를 저장하는 구조\n    count_loc = dict()\n    # 지뢰의 좌표와 폭발 여부를 저장하는 구조\n    bomb_loc = dict()\n\n    # 체크된 곳과 지뢰의 좌표를 저장\n    for x in range(n):\n        for y in range(n):\n            if board[x][y] == &#39;*&#39;:\n                bomb_loc[(x, y)] = False\n            if open_board[x][y] == &#39;x&#39;:\n                count_loc[(x, y)] = 0\n\n    # 주변 칸의 좌표를 반환\n    def get_around(num):\n        _list = []\n        if num-1 &amp;gt;= 0:\n            _list.append(num-1)\n        _list.append(num)\n        if num+1 &amp;lt; n:\n            _list.append(num+1)\n        return _list\n    \n    # 탐색\n    for x, y in bomb_loc.keys():\n        for _x in get_around(x):\n            for _y in get_around(y):\n                if open_board[_x][_y] == &#39;x&#39;:\n                    if board[_x][_y] == &#39;*&#39;:\n                        bomb_loc[(x, y)] = True\n                    count_loc[(_x, _y)] += 1\n\n    # 폭발한 지뢰가 존재하면 표시\n    if True in list(bomb_loc.values()):\n        for x, y in bomb_loc.keys():\n            open_board[x][y] = &#39;*&#39;\n    # 지뢰가 있는 곳을 제외하고 근처 지뢰 수를 기록\n    for x, y in count_loc.keys():\n        if open_board[x][y] != &#39;*&#39;:\n            open_board[x][y] = count_loc[(x, y)]\n\n    open_board = [&#39;&#39;.join(map(str, row)) for row in open_board]\n    print(&#39;\\n&#39;.join(open_board))\n\nsolution(\n\n\n[여담]\n\n문제의 내용만 이해하면 구현 자체는 굉장히 쉬운 난이도의 문제였습니다.\n"
} ,
  
  {
    "title"    : "[백준 4134번] 다음 소수",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/09/04/%EB%B0%B1%EC%A4%80-4134%EB%B2%88.html",
    "date"     : "September 4, 2021",
    "excerpt"  : "\n\n백준 “다음 소수” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n정수 n(0 ≤ n ≤ 4*10의9승)가 주어졌을 때, n보다 크거나 같은 소수 중 가장 작은 소수 찾는 프로그램을 작성하시오.\n\n입력\n\n첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다.\n\n출력\n\n각각의 테스트 케이스에 대해서 n보다 크거나 같은 소수 중 가장 작은 소수를 한 ...",
  "content"  : "\n\n백준 “다음 소수” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n정수 n(0 ≤ n ≤ 4*10의9승)가 주어졌을 때, n보다 크거나 같은 소수 중 가장 작은 소수 찾는 프로그램을 작성하시오.\n\n입력\n\n첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다.\n\n출력\n\n각각의 테스트 케이스에 대해서 n보다 크거나 같은 소수 중 가장 작은 소수를 한 줄에 하나씩 출력한다.\n\n예제 입력 1\n\n3\n6\n20\n100\n\n\n예제 출력 1\n\n7\n23\n101\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  소수 찾기\n  입력된 큰 수(40억)와 같거나 보다 큰 소수 찾기 → 에라토스테네스의 체?\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport sys\ninput = sys.stdin.readline\n\ndef solution():\n    result = []\n    case = int(input())\n\n    # 메모리 사용 효율을 높이기 위해서 제너레이터 사용\n    def gen_range(start, end, step=1):\n        for i in range(start, end, step):\n            yield i\n\n    # 소수인지 확인\n    def is_prime(x):\n        if x &amp;lt;= 1:\n            return False\n\n        m = int(x**0.5)\n        for i in range(2, m+1):\n            if x % i == 0:\n                return False\n\n        return True\n\n    inf = 10**10\n    for _ in range(case):\n        n = int(input())\n        prime = None\n        # 입력된 n ~ inf 중에 소수 찾기\n        for i in gen_range(n, inf):\n            if is_prime(i):\n                prime = str(i)\n                break\n        result.append(prime)\n\n    print(&#39;\\n&#39;.join(result))\n\nsolution()\n\n\n[과정]\n\n에라토스테네스의 체로 작성한 코드는 시간 초과로 실패했습니다.\n\n그래서 단순하게 입력된 1개의 수가 소수인지 확인하며 무한으로 수를 키워가는 방식으로 접근했습니다.\n"
} ,
  
  {
    "title"    : "[백준 2876번] 그래픽스 퀴즈",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/09/04/%EB%B0%B1%EC%A4%80-2876%EB%B2%88.html",
    "date"     : "September 4, 2021",
    "excerpt"  : "\n\n백준 “그래픽스 퀴즈” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n오늘은 기초컴퓨터그래픽스의 퀴즈가 있는 날이다. 기다란 교실 안에는 N개의 책상이 한 줄로 늘어서 있는데, 각 책상당 두 명의 학생이 앉도록 되어있다.\n\n모든 학생들은 그래픽스를  열심히 공부했지만, 말도 안되는 난이도에 질려 포기하고 말았다. 한편 교수님은 각 학생들의 얼굴만 보고도 이 학생이 받아야 할 그레이드를 정확히 알아낼 수...",
  "content"  : "\n\n백준 “그래픽스 퀴즈” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n오늘은 기초컴퓨터그래픽스의 퀴즈가 있는 날이다. 기다란 교실 안에는 N개의 책상이 한 줄로 늘어서 있는데, 각 책상당 두 명의 학생이 앉도록 되어있다.\n\n모든 학생들은 그래픽스를  열심히 공부했지만, 말도 안되는 난이도에 질려 포기하고 말았다. 한편 교수님은 각 학생들의 얼굴만 보고도 이 학생이 받아야 할 그레이드를 정확히 알아낼 수 있다.\n\n교수님은 그래픽스 과목을 가르치는 만큼 자신의 미적 감각을 살리기 위해 각 그레이드를 다른 색을 이용해서 표시한다(예를 들어 A를 빨강으로 칠하면, B,C,D는 빨강으로 표시하지 않는다).\n\n또, 퀴즈의 방식은 교수님이 수업이 시작할 때 어떤 두 책상을 선택하고, 두 책상과 그 사이에 있는 모든 책상에서 각각 한 명씩 지목해서 질문을 하고, 학생의 대답을 듣는 것이다.\n\n오늘 교수님은 바쁜 나머지 한 가지 색의 색연필만 가지고 왔고, 결국 자신의 미학을 지키기 위해 퀴즈에서 지목한 모두에게 같은 그레이드를 주려고 한다. 교수님이 채점할 수 있는 학생의 수는 최대 몇 명일까?\n\n입력\n\n입력의 첫 번째 줄에는 정수 N이 주어진다(1 ≤ N ≤ 100,000).\n\n다음 N개의 줄에는 i번째 책상에 앉은 두 학생이 받아야 할 그레이드 Ai와 Bi(1 ≤ Ai, Bi ≤ 5)가 주어진다.\n\n출력\n\n교수님이 한 가지 색만을 이용해 채점할 수 있는 최대 학생 수와 그때의 그레이드를 출력한다.\n\n만약 답이 여러 가지라면, 가장 작은 그레이드를 출력한다.\n\n예제 입력 1\n\n1\n1 5\n\n\n예제 출력 1\n\n1 1\n\n\n예제 입력 2\n\n3\n3 5\n4 5\n1 3\n\n\n예제 출력 2\n\n2 5\n\n\n예제 입력 3\n\n4\n2 1\n3 2\n5 3\n2 5\n\n\n예제 출력 3\n\n2 2\n\n\n\n\nSolution\n\n[문제 이해]\n\n처음보는 유형의 문제로 검색을 통해 누적 합(Prefix Sum) 알고리즘으로 풀이를 진행했습니다.\n\n\n  입력값 2개 중에 1개 임의로 선택하여 누적 합을 계산\n→ 받을 등급이 같은 학생 수를 누적 합으로 계산\n  누적 합의 수가 동일하면, 등급이 낮은게 우선\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nfrom collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solution():\n    n = int(input())\n    grades = defaultdict(dict)\n    for i in range(n+1):\n        for j in range(6):\n            grades[i][j] = 0\n    max_num = 0\n    max_grade = 0\n\n    # dictionary 구조로 누적합 사용\n    def prefix_sum(i, num):\n        nonlocal max_num, max_grade, grades\n        grades[i][num] = grades[i-1][num] + 1\n        if grades[i][num] &amp;gt; max_num:\n            max_num = grades[i][num]\n            max_grade = num\n        elif grades[i][num] == max_num and max_grade &amp;gt; num:\n            max_grade = num\n\n    for i in range(1, n+1):\n        a, b = map(int, input().split())\n        prefix_sum(i, a)\n        if a != b:\n            prefix_sum(i, b)\n\n    print(max_num, max_grade)\n\nsolution()\n\n\n아래의 코드는 다른 사람의 풀이로, 리스트 자료구조를 사용하여 처리 효율을 높힌 케이스입니다.\n\n[처리 효율이 좋은 코드]\n\n# 처리 효율 좋아서 추가\nimport sys\n\nn = int(sys.stdin.readline())\nres = dict().fromkeys([i for i in range(1, 6)])\nfor i in res:\n    res[i] = []\narr = []\nfor _ in range(n):\n    arr.append(list(map(int, sys.stdin.readline().split())))\nfor k in range(1, 6):\n    size = 0\n    for i in range(n):\n        if arr[i][0] == k or arr[i][1] == k:\n            size += 1\n        else:\n            res[k].append(size)\n            size = 0\n    if size &amp;gt; 0:\n        res[k].append(size)\n\nans = []\nfor i in res:\n    ans.append((i, max(res[i])))\nans.sort(key=lambda x : (-x[1], x[0]))\nprint(ans[0][1], ans[0][0])\n\n\n[과정]\n\n누적 합 알고리즘을 먼저 이해하기 위해서 예제를 작성해봤습니다.\n\n그리고 2개의 입력중 임의의 값이라는 처리를 위해서 dictionary 구조를 사용하여 누적 합 알고리즘을 작성했습니다.\n"
} ,
  
  {
    "title"    : "[백준 1978번] 소수 찾기",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/09/04/%EB%B0%B1%EC%A4%80-1978%EB%B2%88.html",
    "date"     : "September 4, 2021",
    "excerpt"  : "\n\n백준 “소수 찾기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.\n\n입력\n\n첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.\n\n출력\n\n주어진 수들 중 소수의 개수를 출력한다.\n\n예제 입력 1\n\n4\n1 3 5 7\n\n\n예제 출력 1\n\n3\n\n\n\n\nSolu...",
  "content"  : "\n\n백준 “소수 찾기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.\n\n입력\n\n첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.\n\n출력\n\n주어진 수들 중 소수의 개수를 출력한다.\n\n예제 입력 1\n\n4\n1 3 5 7\n\n\n예제 출력 1\n\n3\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  소수 찾기\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[자바 코드]\n\npackage beakjoon;\n\nimport java.util.Scanner;\n\npublic class Main1978 {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint result = 0;\n\t\tfor (int i=0; i &amp;lt; T; i++) {\n\t\t\tint num = sc.nextInt();\n\t\t\tif (isPrime(num)) result ++;\n\t\t}\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tprivate static boolean isPrime(int num) {\n\t\t// TODO Auto-generated method stub\n\t\tif (num &amp;lt; 2) return false;\n\t\tfor (int i=2; i*i &amp;lt;= num; i++) {\n\t\t\tif (num % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n\n\n[파이썬 코드]\n\nimport sys\ninput = sys.stdin.readline\n\n# 라인 수를 줄인 코딩\ndef solution():\n    N = int(input())\n    is_prime = lambda x: 1 if sum([0 if x % i == 0 else 1 for i in range(2, int(x**0.5)+1 if int(x**0.5)+1 != 2 else 3)]) &amp;gt; 0 else 0 if x &amp;gt; 1 else 0\n    result = sum([is_prime(x) for x in map(int, input().split())])\n    print(result)\n\nsolution()\n\n"
} ,
  
  {
    "title"    : "[백준 3613번] Java vs C++",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/09/03/%EB%B0%B1%EC%A4%80-3613%EB%B2%88.html",
    "date"     : "September 3, 2021",
    "excerpt"  : "\n\n백준 “Java vs C++” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\nJava 예찬론자 김동규와 C++ 옹호가 김동혁은 서로 어떤 프로그래밍 언어가 최고인지 몇 시간동안 토론을 하곤 했다. 동규는 Java가 명확하고 에러가 적은 프로그램을 만든다고 주장했고, 동혁이는 Java는 프로그램이 느리고, 긴 소스 코드를 갖는 점과 제네릭 배열의 인스턴스화의 무능력을 비웃었다.\n\n또, 김동규와 김동혁은 ...",
  "content"  : "\n\n백준 “Java vs C++” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\nJava 예찬론자 김동규와 C++ 옹호가 김동혁은 서로 어떤 프로그래밍 언어가 최고인지 몇 시간동안 토론을 하곤 했다. 동규는 Java가 명확하고 에러가 적은 프로그램을 만든다고 주장했고, 동혁이는 Java는 프로그램이 느리고, 긴 소스 코드를 갖는 점과 제네릭 배열의 인스턴스화의 무능력을 비웃었다.\n\n또, 김동규와 김동혁은 변수 이름을 짓는 방식도 서로 달랐다. Java에서는 변수의 이름이 여러 단어로 이루어져있을 때, 다음과 같은 방법으로 변수명을 짓는다.\n\n첫 단어는 소문자로 쓰고, 다음 단어부터는 첫 문자만 대문자로 쓴다. 또, 모든 단어는 붙여쓴다. 따라서 Java의 변수명은 javaIdentifier, longAndMnemonicIdentifier, name, bAEKJOON과 같은 형태이다.\n\n반면에 C++에서는 변수명에 소문자만 사용한다. 단어와 단어를 구분하기 위해서 밑줄(‘_‘)을 이용한다. C++ 변수명은 c_identifier, long_and_mnemonic_identifier, name, b_a_e_k_j_o_o_n과 같은 형태이다.\n\n이 둘의 싸움을 부질없다고 느낀 재원이는 C++형식의 변수명을 Java형식의 변수명으로, 또는 그 반대로 바꿔주는 프로그램을 만들려고 한다. 각 언어의 변수명 형식의 위의 설명을 따라야 한다.\n\n재원이의 프로그램은 가장 먼저 변수명을 입력으로 받은 뒤, 이 변수명이 어떤 언어 형식인지를 알아내야 한다. 그 다음, C++형식이라면 Java형식으로, Java형식이라면 C++형식으로 바꾸면 된다. 만약 C++형식과 Java형식 둘 다 아니라면, 에러를 발생시킨다. 변수명을 변환할 때, 단어의 순서는 유지되어야 한다.\n\n재원이는 프로그램을 만들려고 했으나, 너무 귀찮은 나머지 이를 문제를 읽는 사람의 몫으로 맡겨놨다.\n\n재원이가 만들려고 한 프로그램을 대신 만들어보자.\n\n입력\n\n첫째 줄에 변수명이 주어진다. 영어 알파벳과 밑줄(‘_‘)로만 이루어져 있고, 길이는 100을 넘지 않는다.\n\n출력\n\n입력으로 주어진 변수명이 Java형식이면, C++형식으로 출력하고, C++형식이라면 Java형식으로 출력한다. 둘 다 아니라면 “Error!”를 출력한다.\n\n예제 입력 1\n\nlong_and_mnemonic_identifier\n\n\n예제 출력 1\n\nlongAndMnemonicIdentifier\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  Error가 발생하는 상황\n    \n      처음이 _인 경우\n      끝이 _인 경우\n      처음이 대문자인 경우\n      _가 2개 이상 붙어있는 경우\n      _와 대문자 유형이 섞여있는 경우\n    \n  \n  정규식을 통해 error 상황 처리 후에 변환을 진행\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport sys\nimport re\ninput = sys.stdin.readline\n\ndef solution():\n    # 처음이 _인 경우                 -&amp;gt; _asdf\n    # 끝이 _인 경우                   -&amp;gt; asdf_\n    # 처음이 대문자인 경우            -&amp;gt; AsdfAsdf\n    # _가 2개 이상 붙어있는 경우          -&amp;gt; asdf__asdf\n    # _ 와 대문자 유형이 섞여있는 경우 -&amp;gt; asdf_asdfAsdf\n    err_p = r&#39;^_|_$|^[A-Z]|_{2,}|(?=.*(_)).*[A-Z]&#39;\n    re_err = re.compile(err_p)\n    var_name = input().strip()\n    cpp_to_java = lambda name: &#39;&#39;.join([f&#39;{word[0].upper()}{word[1:]}&#39; if i != 0 else word for i, word in enumerate(name.split(&#39;_&#39;))])\n    java_to_cpp = lambda name: &#39;&#39;.join([c if c.islower() else f&#39;_{c.lower()}&#39; for c in name])\n\n    if re_err.search(var_name) != None:\n        print(&#39;Error!&#39;)\n    else:\n        if &#39;_&#39; in var_name:\n            print(cpp_to_java(var_name))\n        else:\n            print(java_to_cpp(var_name))\n\nsolution()\n\n\n정규식 만세\n"
} ,
  
  {
    "title"    : "[백준 14391번] 종이 조각",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/09/02/%EB%B0%B1%EC%A4%80-14391%EB%B2%88.html",
    "date"     : "September 2, 2021",
    "excerpt"  : "\n\n백준 “종이 조각” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n영선이는 숫자가 쓰여 있는 직사각형 종이를 가지고 있다. 종이는 1×1 크기의 정사각형 칸으로 나누어져 있고, 숫자는 각 칸에 하나씩 쓰여 있다. 행은 위에서부터 아래까지 번호가 매겨져 있고, 열은 왼쪽부터 오른쪽까지 번호가 매겨져 있다.\n\n영선이는 직사각형을 겹치지 않는 조각으로 자르려고 한다. 각 조각은 크기가 세로나 가로 크기가 1...",
  "content"  : "\n\n백준 “종이 조각” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n영선이는 숫자가 쓰여 있는 직사각형 종이를 가지고 있다. 종이는 1×1 크기의 정사각형 칸으로 나누어져 있고, 숫자는 각 칸에 하나씩 쓰여 있다. 행은 위에서부터 아래까지 번호가 매겨져 있고, 열은 왼쪽부터 오른쪽까지 번호가 매겨져 있다.\n\n영선이는 직사각형을 겹치지 않는 조각으로 자르려고 한다. 각 조각은 크기가 세로나 가로 크기가 1인 직사각형 모양이다. 길이가 N인 조각은 N자리 수로 나타낼 수 있다. 가로 조각은 왼쪽부터 오른쪽까지 수를 이어 붙인 것이고, 세로 조각은 위에서부터 아래까지 수를 이어붙인 것이다.\n\n아래 그림은 4×4 크기의 종이를 자른 한 가지 방법이다.\n\n\n\n각 조각의 합은 493 + 7160 + 23 + 58 + 9 + 45 + 91 = 7879 이다.\n\n종이를 적절히 잘라서 조각의 합을 최대로 하는 프로그램을 작성하시오.\n\n입력\n\n첫째 줄에 종이 조각의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 4)\n\n둘째 줄부터 종이 조각이 주어진다. 각 칸에 쓰여 있는 숫자는 0부터 9까지 중 하나이다.\n\n출력\n\n영선이가 얻을 수 있는 점수의 최댓값을 출력한다.\n\n예제 입력 1\n\n2 3\n123\n312\n\n\n예제 출력 1\n\n435\n\n\n예제 입력 2\n\n2 2\n99\n11\n\n\n예제 출력 2\n\n182\n\n\n예제 입력 3\n\n4 3\n001\n010\n111\n100\n\n\n예제 출력 3\n\n1131\n\n\n예제 입력 4\n\n1 1\n8\n\n\n예제 출력 4\n\n8\n\n\n\n\nSolution\n\n[문제 이해]\n\n새로운 유형의 문제였고, 시간초과를 이겨내지 못해서 검색을 통해 풀이를 진행하였습니다.\n\n\n  비트마스킹 사용\n→ 경우의 수를 비트를 이용해서 뽑아내어 원본 데이터를 대입하여 계산하는 방식\n  브루트포스 사용\n\n\n검색을 통해 이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport sys\n# import numpy as np\nfrom itertools import product\ninput = sys.stdin.readline\n\ndef solution():\n    N, M = map(int, input().split())\n    board = [[int(y) for y in x] for _ in range(N) for x in input().split()]\n    \n    # 비트마스킹 데이터 생성\n    bit_masks = product([0, 1], repeat=N*M)\n    result = 0\n\n    # 1차원 배열인 bit_mask 데이터를 2차원 배열로 변환하는 함수\n    def to_matrix(arr):\n        # return np.array_split(arr, N)\n        return [arr[i:i+M] for i in range(0, len(arr), M)]\n\n    # 비트마스킹 데이터에 따라 가로 -&amp;gt; 세로 순으로 연산\n    for case in bit_masks:\n        bit_mask = to_matrix(case)\n        # 행과 열의 총합 변수\n        rows_sum = cols_sum = 0\n\n        # 행 연산\n        for x in range(N):\n            row_sum = 0\n            for y in range(M):\n                if bit_mask[x][y] == 0:\n                    row_sum = row_sum * 10 + board[x][y]\n                if bit_mask[x][y] == 1 or y == (M-1):\n                    rows_sum += row_sum\n                    row_sum = 0\n\n        # 열 연산\n        for y in range(M):\n            col_sum = 0\n            for x in range(N):\n                if bit_mask[x][y] == 1:\n                    col_sum = col_sum * 10 + board[x][y]\n                if bit_mask[x][y] == 0 or x == (N-1):\n                    cols_sum += col_sum\n                    col_sum = 0\n\n        total_sum = rows_sum + cols_sum\n        result = max(result, total_sum)\n\n    print(result)\n\nsolution()\n\n\n[여담]\n\n비트마스킹이란 문제 풀이 방식을 알게 됐습니다.\n\n채점하던 도중 마지막에\n\n\n  “Python 버전을 어떤 걸 쓰길래 ModuleNotFoundError 가 뜨는 걸까?”\n\n\n라는 생각이 들어서 백준 사이트는 외부(numpy) 라이브러리를 지원하지 않는다는 것을 알게 됐습니다.\n\n\n"
} ,
  
  {
    "title"    : "[프로그래머스] 전화번호 목록",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/09/01/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D.html",
    "date"     : "September 1, 2021",
    "excerpt"  : "\n\n프로그래머스 해시 “전화번호 목록” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.\n\n\n  구조대 : 119\n  박준영 : 97 674 223\n  지영석 : 11 9552 4421\n\n\n전화번호부에 적힌 전화번호를 담은...",
  "content"  : "\n\n프로그래머스 해시 “전화번호 목록” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.\n\n\n  구조대 : 119\n  박준영 : 97 674 223\n  지영석 : 11 9552 4421\n\n\n전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.\n\n제한 사항\n\n\n  phone_book의 길이는 1 이상 1,000,000 이하입니다.\n    \n      각 전화번호의 길이는 1 이상 20 이하입니다.\n      같은 전화번호가 중복해서 들어있지 않습니다.\n    \n  \n\n\n입출력 예제\n\n\n  \n    \n      phone_book\n      return\n    \n  \n  \n    \n      [“119”, “97674223”, “1195524421”]\n      false\n    \n    \n      [“123”,”456”,”789”]\n      true\n    \n    \n      [“12”,”123”,”1235”,”567”,”88”]\n      false\n    \n  \n\n\n입출력 예 설명\n\n입출력 예 #1앞에서 설명한 예와 같습니다.\n\n입출력 예 #2한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.\n\n입출력 예 #3첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.\n\n\n\n알림\n\n2021년 3월 4일, 테스트 케이스가 변경되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다.\n\n출처\n\n\n\nSolution\n\n[문제 이해]\n\n\n  phone_book를 정렬\n  기준이 되는 데이터의 근처만 문자열 탐색\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\n# 정렬을 이용해서 비교를 앞자리만 진행한 방식\ndef solution(phone_book):\n    answer = True\n    phone_book = sorted(phone_book)\n\n    # phone_book 리스트에서 데이터를 호출할 때,\n    # phone_book[1:]을 사용하면 다음 데이터를 같이 호출할 수 있다.\n    for ph1, ph2 in zip(phone_book, phone_book[1:]):\n        if ph2.startswith(ph1):\n            answer = False\n            break\n\n    return answer\n\n\n[여담]\n\neasy한 문제\n"
} ,
  
  {
    "title"    : "[백준 1753번] 최단경로",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/31/%EB%B0%B1%EC%A4%80-1753%EB%B2%88.html",
    "date"     : "August 31, 2021",
    "excerpt"  : "\n\n백준 “최단경로” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.\n\n입력\n\n첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는...",
  "content"  : "\n\n백준 “최단경로” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.\n\n입력\n\n첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.\n\n출력\n\n첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.\n\n예제 입력 1\n\n5 6\n1\n5 1 1\n1 2 2\n1 3 3\n2 3 4\n2 4 5\n3 4 6\n\n\n예제 출력 1\n\n0\n2\n3\n7\nINF\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  노드 정보를 그래프에 저장\n  다익스트라 알고리즘으로 최단거리 탐색\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport sys\nimport heapq\ninput = sys.stdin.readline\n\ndef solution():\n    # 다익스트라\n    def dijkstra(start_node, graph):\n        distances = [float(&#39;inf&#39;)] * (V+1)\n        distances[start_node] = 0\n        queue = []\n        heapq.heappush(queue, (0, start_node))\n\n        while queue:\n            cur_distance, cur_node = heapq.heappop(queue)\n            \n            if distances[cur_node] &amp;lt; cur_distance:\n                continue\n            \n            for next_distance, next_node in graph[cur_node]:\n                distance = cur_distance + next_distance\n                if distance &amp;lt; distances[next_node]:\n                    distances[next_node] = distance\n                    heapq.heappush(queue, [distance, next_node])\n\n        return distances\n\n    V, E = input().split()\n    # V: 노드 개수, E: 간선 개수 -&amp;gt; 노드가 이어진 선\n    V, E = int(V), int(E)\n    start = int(input())\n    graph = [[] for _ in range(V+1)]\n\n    for _ in range(E):\n        # u: 출발 노드, v: 도착 노드, w: 거리\n        u, v, w = map(int, input().split())\n        graph[int(u)].append([int(w), int(v)])\n\n    for i in dijkstra(start, graph)[1:]:\n        if i == float(&#39;inf&#39;):\n            print(&#39;INF&#39;)\n        else:\n            print(i)\n\nsolution()\n\n\n[과정]\n\n최초 구현 시에는 그래프를 list가 아닌 dictionary 자료구조를 사용해서 구현했습니다.\n\n하지만 시간 초과라는 결과가 뜨면서 시간 복잡도를 줄이고자 몇 가지를 변경했습니다.\n\n\n  map(int, data) → int(data)\n  dictionary → list\n  함수화\n  comprehention → multiplication\n\n\n[변경 이전의 코드]\n\nimport sys\nimport heapq\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\n# 다익스트라\ndef dijkstra(start_node, graph):\n    # 리스트 컴프리헨션을 사용하여 정의\n    distances = [float(&#39;inf&#39;) for _ in range(V+1)]\n    distances[start_node] = 0\n    queue = []\n    heapq.heappush(queue, (0, start_node))\n\n    while queue:\n        cur_distance, cur_node = heapq.heappop(queue)\n        \n        if distances[cur_node] &amp;lt; cur_distance:\n            continue\n        \n        # 자료구조가 dictionary라서 items() 함수를 사용\n        for next_node, next_distance in graph[cur_node].items():\n            distance = cur_distance + next_distance\n            if distance &amp;lt; distances[next_node]:\n                distances[next_node] = distance\n                heapq.heappush(queue, [distance, next_node])\n\n    return distances\n\n# 정수 변환을 위해 map() 함수 사용\nV, E = map(int, input().split())\nstart = int(input())\n# 처음의 자료구조 dictionary 선언\ngraph = defaultdict(dict)\n\nfor _ in range(E):\n    # 정수 변환을 위해 map() 함수 사용\n    u, v, w = map(int, input().split())\n    # dictionary 데이터 추가 형식\n    graph[u][v] = w\n\nfor i in dijkstra(start, graph)[1:]:\n    if i == float(&#39;inf&#39;):\n        print(&#39;INF&#39;)\n    else:\n        print(i)\n\n\n[여담]\n\ngraph 생성 시에 컴프리헨션을 사용한 이유는 *(곱하기)를 사용할 경우 mutable 데이터인 빈 list의 주소값이 복사되기 때문에 데이터 처리가 정상적으로 되지않아서 컴프리헨션을 사용했습니다.\n\n\n  [Python] 리스트 복사 - 보러가기\n\n"
} ,
  
  {
    "title"    : "[현대 모비스 경진대회] 4번",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/29/%ED%98%84%EB%8C%80-%EB%AA%A8%EB%B9%84%EC%8A%A4-%EA%B2%BD%EC%A7%84%EB%8C%80%ED%9A%8C-4%EB%B2%88.html",
    "date"     : "August 29, 2021",
    "excerpt"  : "\n\n현대 모비스 경진대회 “4번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  하나의 리스트의 원소들을 변형해서 다른 리스트의 원소들 형태로 구성 가...",
  "content"  : "\n\n현대 모비스 경진대회 “4번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  하나의 리스트의 원소들을 변형해서 다른 리스트의 원소들 형태로 구성 가능 여부\n  p값으로 생성 가능한 리스트 필요\n→ 조합\n  p값 중 가장 작은 값이 q값 중 가장 작은 값보다 크면 false\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nfrom itertools import combinations\n\ndef solution(p, q):\n    answer = []\n    for x, y in zip(p, q):\n        # y에 x보다 더 작은 값이 존재하면 만들 수 없음\n        if min(x) &amp;gt; min(y):\n            answer.append(False)\n            continue\n\n        # x로 생성 가능한 조합\n        # {idx: [조합 숫자 2개, 숫자의 합]}\n        sum_data = {i: [c, sum(c)] for i, c in enumerate(combinations(x, 2))}\n\n        for i in sum_data:\n            if sum_data[i][1] in y:\n                x[x.index(sum_data[i][0][0])] = sum_data[i][1]\n                del x[x.index(sum_data[i][0][1])]\n            else:\n                continue\n            if x.sort() == y.sort():\n                answer.append(True)\n                break\n        # 생성 가능 조합 모두 확인해도 없으면 false처리\n        else:\n            answer.append(False)\n\n    return answer\n\n\n[여담]\n\n정답을 확인할 수 없기 때문에 가지고 있는 테스트 케이스를 만족하는 수준까지만 풀이를 진행하였습니다.\n\n문제에 대해서 틀린 점 혹은 다른 해석은 언제나 환영합니다.\n(상단의 이메일 참고)\n"
} ,
  
  {
    "title"    : "[현대 모비스 경진대회] 3번",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/29/%ED%98%84%EB%8C%80-%EB%AA%A8%EB%B9%84%EC%8A%A4-%EA%B2%BD%EC%A7%84%EB%8C%80%ED%9A%8C-3%EB%B2%88.html",
    "date"     : "August 29, 2021",
    "excerpt"  : "\n\n현대 모비스 경진대회 “3번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  bitwise and 연산을 통해서 0을 만들기 위한 리스트를 반환\n ...",
  "content"  : "\n\n현대 모비스 경진대회 “3번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  bitwise and 연산을 통해서 0을 만들기 위한 리스트를 반환\n  a[n]의 bitwise and 연산의 결과가 return값\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\ndef solution(m, b):\n    # b를 m에 의해 나눈 2차원 리스트\n    temp = [b[sum(m[0:i]):sum(m[0:i+1])] if i != 0 else b[0:n] for i, n in enumerate(m)]\n    \n    # bitwise and 연산 결과 -&amp;gt; 10진수 반환\n    def BitwiseAnd(a, b):\n        a = bin(a)[2:]\n        b = bin(b)[2:]\n        a_leng = len(a)\n        b_leng = len(b)\n        if a_leng &amp;gt;= b_leng:\n            leng = a_leng\n            b = b.zfill(leng)\n        else:\n            leng = b_leng\n            a = a.zfill(leng)\n\n        result = &#39;&#39;\n        for n1, n2 in zip(a, b):\n            if n1 == n2:\n                result += n1\n            else:\n                result += &#39;0&#39;\n            \n        return int(result, 2)\n\n    # 입력된 리스트의 요소를 bitwise and 연산하는 재귀함수\n    def recursion(_list):\n        _list = _list[:]\n        while len(_list) &amp;gt; 1:\n            bin_num = BitwiseAnd(_list[0], _list[1])\n            _list[0] = bin_num\n            del _list[1]\n        if len(_list) == 1:\n            _list = _list[0]\n        else:\n            _list = recursion(_list)\n\n        return _list\n\n    answer = []\n    # 나눠둔 리스트의 요소를 연산에 대입\n    for n in temp:\n        answer.append(recursion(n))\n\n    return answer\n\n\n[여담]\n\n정답을 확인할 수 없기 때문에 가지고 있는 테스트 케이스를 만족하는 수준까지만 풀이를 진행하였습니다.\n\n문제에 대해서 틀린 점 혹은 다른 해석은 언제나 환영합니다.\n(상단의 이메일 참고)\n"
} ,
  
  {
    "title"    : "[현대 모비스 경진대회] 2번",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/27/%ED%98%84%EB%8C%80-%EB%AA%A8%EB%B9%84%EC%8A%A4-%EA%B2%BD%EC%A7%84%EB%8C%80%ED%9A%8C-2%EB%B2%88.html",
    "date"     : "August 27, 2021",
    "excerpt"  : "\n\n현대 모비스 경진대회 “2번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  맨 앞 or 뒤가 a인 경우 제거\n  맨 앞뒤가 모두 b인 경우 제거\n...",
  "content"  : "\n\n현대 모비스 경진대회 “2번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  맨 앞 or 뒤가 a인 경우 제거\n  맨 앞뒤가 모두 b인 경우 제거\n  제거하다 마지막에 남은 문자가 a면 true, b면 false\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[답안 제출 코드]\n\ndef solution(a):\n    answer = []\n\n    for s in a:\n        while True:\n            flag = 0\n            if s[0] == &#39;a&#39;:\n                flag += 1\n                s = s[1:]\n            if s[-1] == &#39;a&#39;:\n                flag += 1\n                s = s[:-1]\n\n            if s[0] == &#39;b&#39; and s[-1] == &#39;b&#39;:\n                flag += 1\n                x = s.count(&#39;a&#39;)\n                while x &amp;gt; 0 and s[0] == &#39;b&#39;:\n                    s = s[1:-1]\n                    x -= 1\n            \n            if &#39;b&#39; not in s or &#39;a&#39; not in s or flag == 0:\n                break\n\n        if s == &#39;a&#39;:\n            answer.append(True)\n            continue\n        else:\n            answer.append(False)\n            continue\n\n    return answer\n\n\n코드 실행 시 테스트 케이스가 1개 빼고 모두 실패가 나와서 정말 의문이었습니다.\n\n하지만 답안 제출이 끝나고 난 뒤에 다시 코드를 확인해보니 크게 실수한 부분이 있었습니다.\n\n[원래 의도한 코드]\n\ndef solution(a):\n    answer = []\n\n    for s in a:\n        while True:\n            flag = 0\n            if s[0] == &#39;a&#39;:\n                flag += 1\n                s = s[1:]\n            if s[-1] == &#39;a&#39;:\n                flag += 1\n                s = s[:-1]\n\n            if s[0] == &#39;b&#39; and s[-1] == &#39;b&#39;:\n                flag += 1\n                s = s[1:-1]\n            \n            if &#39;b&#39; not in s or &#39;a&#39; not in s or flag == 0:\n                break\n\n        if s == &#39;a&#39;:\n            answer.append(True)\n            continue\n        else:\n            answer.append(False)\n            continue\n\n    return answer\n\n\nb를 제거하는 조건문에 while문을 넣었던 것이 잘못이었습니다.\n\n문제를 풀기위해 이것저것 넣어보면 테스트하던 코드가 일부 남아있었습니다…\n\n풀이가 의도대로 되었다면 맞출 수 있었던 문제였기에 너무 아쉬웠습니다.\n"
} ,
  
  {
    "title"    : "[현대 모비스 경진대회] 1번",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/27/%ED%98%84%EB%8C%80-%EB%AA%A8%EB%B9%84%EC%8A%A4-%EA%B2%BD%EC%A7%84%EB%8C%80%ED%9A%8C-1%EB%B2%88.html",
    "date"     : "August 27, 2021",
    "excerpt"  : "\n\n현대 모비스 경진대회 “1번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  dice 데이터를 가지고 순열 데이터 생성\n  비교 방식을 set() ...",
  "content"  : "\n\n현대 모비스 경진대회 “1번” 문제를 풀어보았습니다.\n\n\n  혹시 해당 포스팅이 저작권상 문제가 되는 경우 이메일로 연락을 주시면 조치하도록 하겠습니다.\n\n  이메일 - jano.jeon@gmail.com\n\n\n\n\nSolution\n\n문제를 유출하지 말라는 조건이 있었기 때문에 문제는 생략하고\n본인의 문제에 대한 이해 부분과 코드만 작성했습니다.\n\n[문제 이해]\n\n\n  dice 데이터를 가지고 순열 데이터 생성\n  비교 방식을 set() - set() 형태로 진행\n  순열 데이터 중에 만들어지지 않은 가장 작은 데이터 반환\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[답안 제출 코드]\n\nfrom itertools import permutations\n\ndef solution(dice):\n    temp = []\n    for i in dice:\n        temp += set(i)\n    \n    data = []\n    for n in range(1, len(dice)+1):\n        data += [int(&#39;&#39;.join(map(str, i))) for i in list(permutations(temp, n))]\n    data = list(set(data))\n    check_data = list(range(data[0], data[-1]+1))\n    answer = sorted(set(check_data) - set(data))\n    if answer[0] == 0:\n        return answer[1]\n    else:\n        return answer[0]\n\n\n완성인 줄 알았지만, 코드 실행 시 1개의 테스트 케이스가 실패하였습니다.\n\n실패한 테스트 케이스를 찾으면 업데이트 예정입니다.\n"
} ,
  
  {
    "title"    : "[Python] 리스트 복사",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/2021/08/25/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%B3%B5%EC%82%AC.html",
    "date"     : "August 25, 2021",
    "excerpt"  : "\n\n내가 그랬듯이 파이썬 사용자들이 자주 헷갈려하는 리스트 복사에 대한 내용을 정리했습니다.\n\n파이썬의 리스트 복사는 4가지 경우가 있습니다.\n\n\n  데이터를 가리키는 메모리 주소를 복사하는 경우\n  데이터 자체를 복사하는 경우\n  mutable 데이터의 메모리 주소를 복사하는 경우\n  mutable 데이터 자체를 복사하는 경우\n\n\n보기쉽게 코드로 먼저 확인해보겠습니다.\n\n[1번 코드]\n\norigin_data = [1, 2, 3, 4, 5...",
  "content"  : "\n\n내가 그랬듯이 파이썬 사용자들이 자주 헷갈려하는 리스트 복사에 대한 내용을 정리했습니다.\n\n파이썬의 리스트 복사는 4가지 경우가 있습니다.\n\n\n  데이터를 가리키는 메모리 주소를 복사하는 경우\n  데이터 자체를 복사하는 경우\n  mutable 데이터의 메모리 주소를 복사하는 경우\n  mutable 데이터 자체를 복사하는 경우\n\n\n보기쉽게 코드로 먼저 확인해보겠습니다.\n\n[1번 코드]\n\norigin_data = [1, 2, 3, 4, 5]\ncopy_data = origin_data\n\n# id()는 파이썬이 객체를 구별하기 위해 부여하는 코드값\n# 동일 객체 여부를 판별할 때 사용\nprint(f&#39;origin_data: {origin_data} / id: {id(origin_data)}&#39;)\nprint(f&#39;copy_data: {copy_data} / id: {id(copy_data)}&#39;)\n\n\n\n\n결과를 보면 id값이 동일한 것을 보아 같은 데이터라고 볼 수 있습니다.\n\n그리고\n\ncopy_data의 데이터를 변경해봤습니다.\n\ncopy_data[0] = 10\nprint(f&#39;origin_data: {origin_data} / id: {id(origin_data)}&#39;)\nprint(f&#39;copy_data: {copy_data} / id: {id(copy_data)}&#39;)\n\n\n\n\norigin_data의 데이터 역시 변경된 것을 확인할 수 있습니다.\n이것으로 copy_data 변수는 origin_data의 메모리 주소를 복사했다는 것을 알 수 있습니다.\n\n[2번 코드]\n\nfrom copy import copy\norigin_data = [1, 2, 3, 4, 5]\ncopy_data1 = origin_data[:]\ncopy_data2 = copy(origin_data)\n# 아래는 위의 2가지 방식과 동일하게 복사되는 방법\n# copy_data = list(origin_data)\n# copy_data = [] + origin_data\n\nprint(f&#39;origin_data: {origin_data} / id: {id(origin_data)}&#39;)\nprint(f&#39;copy_data1: {copy_data1} / id: {id(copy_data1)}&#39;)\nprint(f&#39;copy_data2: {copy_data2} / id: {id(copy_data2)}&#39;)\n\n\n\n\nid값이 각각 다르게 나온 것을 보면 [:]와 copy() 모두 원하던 데이터 복사가 수행된 것을 볼 수 있습니다.\n\ncopy_data1, 2의 데이터를 변경해봤습니다.\n\ncopy_data[0] = 10\nprint(f&#39;origin_data: {origin_data} / id: {id(origin_data)}&#39;)\nprint(f&#39;copy_data: {copy_data} / id: {id(copy_data)}&#39;)\n\n\n\n\ncopy_data1, 2를 변경해도 origin_data가 변경되지 않는 것을 확인할 수 있습니다.\n\n이게 완전히 복사가 된 것일까?\n\n아닙니다, origin_data의 데이터가 mutable 객체인 경우는 다릅니다.\n\n[3번 코드]\n\nfrom copy import copy\norigin_data = [[1, 2], [3, 4]]\ncopy_data1 = origin_data[:]\ncopy_data2 = copy(origin_data)\n\ncopy_data1[0][0] = 10\ncopy_data2[1] = 20\nprint(f&#39;origin_data: {origin_data} / id: {id(origin_data)}&#39;)\nprint(f&#39;copy_data1: {copy_data1} / id: {id(copy_data1)}&#39;)\nprint(f&#39;copy_data2: {copy_data2} / id: {id(copy_data2)}&#39;)\n\n\n\n\ncopy_data1의 0번 인덱스의 데이터는 [1, 2] 로 mutable 데이터입니다.\nmutable 데이터 안에 있는 데이터를 변경하는 경우는 origin_data의 메모리 주소를 복사해서 갖고 있기 때문에 copy_data1, 2의 데이터가 모두 변하는 것을 확인할 수 있습니다.\n3개 변수 모두 : [1, 2] → [10, 2]\n\n하지만 mutable 데이터 전체를 다른 데이터 20 으로 변경한 경우는 정상적으로 copy_data2만 변경된 것을 확인할 수 있습니다.\ncopy_data2만 : [3, 4] → 20\n\n이런 문제를 해결하기 위해서는 4번 방식을 사용해야 합니다.\n\n[4번 코드]\n\nfrom copy import deepcopy\norigin_data = [[1, 2], [3, 4]]\ncopy_data1 = deepcopy(origin_data)\n\ncopy_data1[0][0] = 10\nprint(f&#39;origin_data: {origin_data} / id: {id(origin_data)}&#39;)\nprint(f&#39;copy_data1: {copy_data1} / id: {id(copy_data1)}&#39;)\n\n\n\n\ndeepcopy() 함수를 사용한 복사만 mutable 데이터까지 완전하게 복사되는 것을 확인할 수 있습니다.\n\n하지만 그렇다고 deepcopy()가 만능은 아닙니다.\n\n이유는 복사하는 속도의 차이가 굉장히 크기 때문입니다.\n\n속도가 가장 빠른 슬라이스 형식의 복사 [:] 에 비해서 deepcopy 복사는 30배 이상 느립니다.\n\n그렇기 때문에 상황에 맞는 방식을 적절히 사용해야 합니다.\n\n\n  📌 Stack Overflow - 복사 속도에 대한 내용\n\n"
} ,
  
  {
    "title"    : "[프로그래머스] 직업군 추천하기",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9C%84%ED%81%B4%EB%A6%AC-%EC%B1%8C%EB%A6%B0%EC%A7%80-4%EC%A3%BC%EC%B0%A8.html",
    "date"     : "August 24, 2021",
    "excerpt"  : "\n\n프로그래머스 위클리 챌린지 4주차 “직업군 추천하기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n\n\n  \n    \n      점수\n      SI\n      CONTENTS\n      ...",
  "content"  : "\n\n프로그래머스 위클리 챌린지 4주차 “직업군 추천하기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.\n\n아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.\n\n\n  \n    \n      점수\n      SI\n      CONTENTS\n      HARDWARE\n      PORTAL\n      GAME\n    \n  \n  \n    \n      5\n      JAVA\n      JAVASCRIPT\n      C\n      JAVA\n      C++\n    \n    \n      4\n      JAVASCRIPT\n      JAVA\n      C++\n      JAVASCRIPT\n      C#\n    \n    \n      3\n      SQL\n      PYTHON\n      PYTHON\n      PYTHON\n      JAVASCRIPT\n    \n    \n      2\n      PYTHON\n      SQL\n      JAVA\n      KOTLIN\n      C\n    \n    \n      1\n      C#\n      C++\n      JAVASCRIPT\n      PHP\n      JAVA\n    \n  \n\n\n예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다. SQL의 HARDWARE, PORTAL, GAME 직업군 언어 점수는 0점입니다.\n\n직업군 언어 점수를 정리한 문자열 배열 table, 개발자가 사용하는 언어를 담은 문자열 배열 languages, 언어 선호도를 담은 정수 배열 preference가 매개변수로 주어집니다. 개발자가 사용하는 언어의 언어 선호도 x 직업군 언어 점수의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요. 총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.\n\n\n\n제한사항\n\n\n  table의 길이 = 5\n    \n      table의 원소는 &quot;직업군 5점언어 4점언어 3점언어 2점언어 1점언어&quot;형식의 문자열입니다. 직업군, 5점언어, 4언어, 3점언어, 2점언어, 1점언어는 하나의 공백으로 구분되어 있습니다.\n      table은 모든 테스트케이스에서 동일합니다.\n    \n  \n  1 ≤ languages의 길이 ≤ 9\n    \n      languages의 원소는 &quot;JAVA&quot;, &quot;JAVASCRIPT&quot;, &quot;C&quot;, &quot;C++&quot; ,&quot;C#&quot; , &quot;SQL&quot;, &quot;PYTHON&quot;, &quot;KOTLIN&quot;, &quot;PHP&quot; 중 한 개 이상으로 이루어져 있습니다.\n      languages의 원소는 중복되지 않습니다.\n    \n  \n  preference의 길이 = languages의 길이\n    \n      1 ≤ preference의 원소 ≤ 10\n    \n  \n  preference의 i번째 원소는 languages의 i번째 원소의 언어 선호도입니다.\n  return 할 문자열은 &quot;SI&quot;, &quot;CONTENTS&quot;, &quot;HARDWARE&quot;, &quot;PORTAL&quot;, &quot;GAME&quot; 중 하나입니다.\n\n\n\n\n입출력 예\n\n\n  \n    \n      table\n      languages\n      preference\n      result\n    \n  \n  \n    \n      [“SI JAVA JAVASCRIPT SQL PYTHON C#”, “CONTENTS JAVASCRIPT JAVA PYTHON SQL C++”, “HARDWARE C C++ PYTHON JAVA JAVASCRIPT”, “PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP”, “GAME C++ C# JAVASCRIPT C JAVA”]\n      [“PYTHON”, “C++”, “SQL”]\n      [7, 5, 5]\n      “HARDWARE”\n    \n    \n      [“SI JAVA JAVASCRIPT SQL PYTHON C#”, “CONTENTS JAVASCRIPT JAVA PYTHON SQL C++”, “HARDWARE C C++ PYTHON JAVA JAVASCRIPT”, “PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP”, “GAME C++ C# JAVASCRIPT C JAVA”]\n      [“JAVA”, “JAVASCRIPT”]\n      [7, 5]\n      “PORTAL”\n    \n  \n\n\n\n\n입출력 예 설명\n\n입출력 예 #1\n\n각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.\n\n\n\n아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.\n\n\n\n따라서 점수 총합이 41로 가장 높은 &quot;HARDWARE&quot;를 return 해야 합니다.\n\n입출력 예 #2\n\n각 직업군 별로 점수를 계산해보면 아래와 같습니다.\n\n아래 사진은 개발자 언어 선호도 나타낸 표입니다.\n\n\n\n아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.\n\n\n\n점수 총합이 55로 가장 높은 직업군은 “SI” 와 “PORTAL”입니다.\n\n따라서 사전 순으로 먼저 오는\n\n&quot;PORTAL&quot;\n\n\n을 return 해야 합니다.\n\n\n\nSolution\n\n[문제 이해]\n\n\n  입력되는 직군별 언어에 대한 점수 할당\n  언어별 총점 계산\n  정렬을 통해 결론 도출\n  점수가 같을 경우 언어의 알파벳 오름차순\n\n\n마지막 점수가 같을 경우 언어의 알파벳 오름차순 만 조심하면 풀이 자체는 간단했습니다.\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[1차 풀이 코드]\n\nfrom collections import Counter, defaultdict\n\ndef solution(table, languages, preference):\n    # 직군별 언어 점수를 할당하기 위한 변수\n    setTable = defaultdict(dict)\n    # 선호도 점수 할당\n    setLang = {l: score for l, score in zip(languages, preference)}\n    # 직군별 언어 점수를 할당\n    for row in table:\n        data = row.split()\n        setTable[data[0]]\n        for i, col in enumerate(data[1:]):\n            setTable[data[0]][col] = 5 - i\n\n    # 직군별 점수 계산을 위한 변수\n    job_score = {}\n    # 직군별 점수 계산\n    for job in setTable:\n        overlap = Counter(setTable[job].keys()) + Counter(languages)\n        scores = 0\n        for lang in overlap:\n            if overlap[lang] == 2:\n                scores += (setLang[lang] * setTable[job][lang])\n        else:\n            job_score[job] = scores\n\n    # lambda x의 정렬 기준 \n    # -x[1]: 점수별 오름차순 정렬 -&amp;gt; 마이너스를 붙여 역으로 내림차순 정렬됨\n    # x[0]: 알파벳별 오름차순 정렬\n    answer = sorted(job_score.items(), key=lambda x: (-x[1], x[0]))[0][0]\n    return answer\n\n\n[여담]\n\n3주차 문제의 비해 난이도가 굉장히 낮아졌다고 생각했습니다.\n\n이번 문제는 풀이 시간 단축에 중점을 두고 풀었습니다.\n\n하지만 생각했던 것 보다는 조금 지체됐습니다.\n\n그리고 효율성을 위해 최적화를 한 번 진행해봤습니다.\n\n[최적화 코드]\n\ndef solution(table, languages, preference):\n    # 직군별 점수 계산을 위한 변수\n    job_score = {}\n    for row in table:\n        data = row.split()\n        # dictionary 자료형에 key 값으로 직군 할당, value는 0으로 초기화\n        job_score[data[0]] = 0\n        for lang, score in zip(languages, preference):\n            # 직군별 점수 계산\n            if lang in data:\n                job_score[data[0]] += (6 - data.index(lang)) * score\n\n    # 위와 동일\n    # -x[1]: 점수별 오름차순 정렬 -&amp;gt; 마이너스를 붙여 역으로 내림차순 정렬됨\n    # x[0]: 알파벳별 오름차순 정렬\n    answer = sorted(job_score.items(), key=lambda x: (-x[1], x[0]))[0][0]\n    return answer\n\n\n처리 시간도 아주 짧게 나온 최적화 코드였습니다.\n\n처리 시간 비교를 위해서 하단에 1 - (처리 시간) 결과도 첨부했습니다.\n\n\n"
} ,
  
  {
    "title"    : "[프로그래머스] 퍼즐 조각 채우기",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9C%84%ED%81%B4%EB%A6%AC-%EC%B1%8C%EB%A6%B0%EC%A7%80-3%EC%A3%BC%EC%B0%A8.html",
    "date"     : "August 23, 2021",
    "excerpt"  : "\n\n프로그래머스 위클리 챌린지 3주차 “퍼즐 조각 채우기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다.\n\n\n  조각은 한 번에 하나씩 채워 넣습니다...",
  "content"  : "\n\n프로그래머스 위클리 챌린지 3주차 “퍼즐 조각 채우기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다.\n\n\n  조각은 한 번에 하나씩 채워 넣습니다.\n  조각을 회전시킬 수 있습니다.\n  조각을 뒤집을 수는 없습니다.\n  게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.\n\n\n다음은 퍼즐 조각을 채우는 예시입니다.\n\n\n\n위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다.\n\n이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다.\n\n\n\n\n  3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다.\n  5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다.\n\n\n다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다.\n\n\n\n최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다.\n\n현재 게임 보드의 상태 game_board, 테이블 위에 놓인 퍼즐 조각의 상태 table이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요.\n\n\n\n제한사항\n\n\n  3 ≤ game_board의 행 길이 ≤ 50\n  game_board의 각 열 길이 = game_board의 행 길이\n    \n      즉, 게임 보드는 정사각 격자 모양입니다.\n      game_board의 모든 원소는 0 또는 1입니다.\n      0은 빈칸, 1은 이미 채워진 칸을 나타냅니다.\n      퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.\n    \n  \n  table의 행 길이 = game_board의 행 길이\n  table의 각 열 길이 = table의 행 길이\n    \n      즉, 테이블은 game_board와 같은 크기의 정사각 격자 모양입니다.\n      table의 모든 원소는 0 또는 1입니다.\n      0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다.\n      퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.\n    \n  \n  game_board에는 반드시 하나 이상의 빈칸이 있습니다.\n  table에는 반드시 하나 이상의 블록이 놓여 있습니다.\n\n\n\n\n입출력 예\n\n\n  \n    \n      game_board\n      table\n      result\n    \n  \n  \n    \n      [[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]]\n      [[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]]\n      14\n    \n    \n      [[0,0,0],[1,1,0],[1,1,1]]\n      [[1,1,1],[1,0,0],[0,0,0]]\n      0\n    \n  \n\n\n\n\n입출력 예 설명\n\n입출력 예 #1\n\n입력은 다음과 같은 형태이며, 문제의 예시와 같습니다.\n\n\n\n입출력 예 #2\n\n블록의 회전은 가능하지만, 뒤집을 수는 없습니다.\n\n\n\nSolution\n\n[문제 이해]\n\n\n  board와 table에서 블록 or 빈 공간의 좌표를 얻어야함\n  얻은 좌표들을 끼리끼리 모아두기\n  빈 공간에 블록을 돌려가며 비교\n→ 블록 회전 기능이 필요\n  결과는 채워진 공간의 합\n\n\n이번 문제는 한 눈에 봐도 난이도가 꽤 되는 문제였습니다.\n\n하지만 코딩 테스트가 얼마 남지 않은 기념?으로 검색을 하지 않고 문제 풀이에 도전했습니다.\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nfrom collections import deque, defaultdict\nimport numpy as np\n\ndef solution(game_board, table):\n    # ↓, →, ↑, ← 이동 좌표\n    step = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n    # 보드에서 n이 있는 위치를 구함\n    def getLoc(boards, n=1):\n        n_arr = list()\n        for x, board in enumerate(boards):\n            [n_arr.append((x, y)) for y in list(np.where(np.array(board)==n)[0])]\n        return n_arr\n\n    # loc 배열을 조합\n    def combineLoc(locs):\n        nonlocal step\n        loc_dict = defaultdict(list)\n        dq = deque()\n        dq.append(locs[0])\n        count = 1\n        loc_dict[count].append((locs[0][0], locs[0][1]))\n        del locs[0]\n\n        while dq:\n            x, y = dq.popleft()\n            for moveX, moveY in step:\n                newX = x + moveX\n                newY = y + moveY\n                if (newX, newY) in locs:\n                    loc_dict[count].append((newX, newY))\n                    dq.appendleft((newX, newY))\n                    del locs[locs.index((newX, newY))]\n            else:\n                if not dq and len(locs) != 0:\n                    dq.append(locs[0])\n                    count += 1\n                    loc_dict[count].append((locs[0][0], locs[0][1]))\n                    del locs[0]\n        return loc_dict\n\n    # 리스트 회전 함수\n    # -&amp;gt; numpy.rot90() 똑같은 기능의 함수 (풀고 검색해봄)\n    def rotation(block):\n        block = np.array(list(zip(*block[::-1])))\n        return block.tolist()\n\n    # 불필요한 0 라인 제거, 같은 모양에도 불구하고 0 라인 때문에 틀림\n    # -&amp;gt; 이 부분 때문에 테스트가 계속 실패하여 마지막에 추가함, 풀이 2일 걸린 원흉\n    def removeZero(arr):\n        temp = []\n        for i, a in enumerate(arr):\n            if sum(a) == 0:\n                temp.append(i)\n        else:\n            if len(temp) == 0:\n                arr = rotation(arr)\n                for i, a in enumerate(arr):\n                    if sum(a) == 0:\n                        temp.append(i)\n        while temp != []:\n            del arr[temp[-1]]\n            del temp[-1]\n\n        return arr\n    \n    def getFrame(leng):\n        return [[0] * leng for _ in range(leng)]\n\n    # 모양 비교를 위해 블록과 빈 공간 구분없이 1로 통일하여 프레임에 배치\n    def setFrame(block):\n        # 2개 리스트로 분할\n        list_x, list_y = zip(*block)\n        min_x, max_x, min_y, max_y = min(list_x), max(list_x), min(list_y), max(list_y)\n        _x = max_x - min_x\n        _y = max_y - min_y\n        # 프레임 길이\n        leng = (_x if _x &amp;gt; _y else _y) + 1\n        arr = getFrame(leng)\n        for x, y in block:\n            arr[x-min_x][y-min_y] = 1\n\n        arr = removeZero(arr)\n\n        return arr\n\n    # 빈 공간과 블록 모양 비교\n    def scanShape(empty, block, n=3):\n        # 빈 공간\n        empty_arr = setFrame(empty)\n        # 블록\n        block_arr = setFrame(block)\n\n        leng = len(block_arr)\n        if leng != len(empty_arr):\n            return False\n        if empty_arr == block_arr:\n            return True\n\n        # 블록 회전하며 확인, n=1 -&amp;gt; 시계 방향으로 90도 회전\n        for _ in range(n):\n            block_arr = rotation(block_arr)\n            if empty_arr == block_arr:\n                return True\n\n        return False\n\n    def scanMap(game_board, table):\n        count = 0\n        dq = deque()\n        # 빈 공간 좌표 list (무작위 상태)\n        empty_loc = getLoc(game_board, 0)\n        # 블록 좌표 list (무작위 상태)\n        block_loc = getLoc(table)\n\n        # 빈 공간 좌표 dict (공간별 정리)\n        empty_comb = combineLoc(empty_loc)\n        # 블록 좌표 dict (블록별 정리)\n        block_comb = combineLoc(block_loc)\n\n        dq.append(list(empty_comb.keys())[0])\n\n        # 빈 공간에 블록을 비교\n        # 일치하면 공간과 블록 제거해가며 비교\n        while dq:\n            e_k = dq.popleft()\n            for b_k in block_comb:\n                if scanShape(empty_comb[e_k], block_comb[b_k]):\n                    count += len(block_comb[b_k])\n                    if len(empty_comb) &amp;gt;= 1:\n                        del empty_comb[e_k]\n                        del block_comb[b_k]\n                        if len(empty_comb) != 0:\n                            dq.append(list(empty_comb.keys())[0])\n                    break\n            else:\n                if len(empty_comb) &amp;gt;= 1:\n                    del empty_comb[e_k]\n                    if len(empty_comb) != 0:\n                        dq.append(list(empty_comb.keys())[0])\n\n        return count\n\n    answer = scanMap(game_board, table)\n    return answer\n\n\n[여담]\n\n우선은 통과한 것에 의의를 두었습니다.\n\n풀이 방식을 프레임을 두고 블록과 빈 공간을 올려서 비교하는 방법을 사용했는데 프레임의 빈 공간 차이로 실패했습니다.\n→ 이 부분을 찾지 못해서 풀이 시간이 굉장히 오래걸렸습니다.\n\n검색없이 구현을 하다보니 잘 정리가 되지 않았지만 정리하는 습관을 들일 수 있도록 노력을 좀 해야할 것 같습니다.\n\n다른 사람의 풀이 중에 기억에 남는 풀이가 2개 있었습니다.\n\n\n  풀이 방식은 비슷하지만 dataclass 를 사용해서 데이터를 클래스로 관리한 코드\n(제 코드와 방식이 비슷해서 처리 시간은 2번에 비해 느리다)\n  처리 시간 효율 끝판왕\n(제 코드는 가장 오래걸린 처리 시간이 695ms 인데 2번 코드는 9ms입니다…)\n\n\nif scanShape() 같은 실수를 하지 않았으면 좋았을 것 같다.\n오늘도 배운다.\n\n[1번 코드]\n\nfrom collections import Counter\nfrom dataclasses import dataclass\nfrom itertools import product\n\n@dataclass(frozen=True)\nclass Pos:\n    x: int\n    y: int\n\n    def neighbors(self):\n        return [\n            Pos(self.x, self.y - 1),\n            Pos(self.x + 1, self.y),\n            Pos(self.x, self.y + 1),\n            Pos(self.x - 1, self.y),\n        ]\n\ndef make_tile_from_positions(positions):\n    &quot;&quot;&quot;Smallest possible representation with rotation&quot;&quot;&quot;\n\n    def rotate90(tile):\n        return tuple(\n            tuple(tile[i][j] for i in range(len(tile)))\n            for j in reversed(range(len(tile[0])))\n        )\n\n    positions = set(positions)\n\n    xs = [pos.x for pos in positions]\n    min_x = min(xs)\n    max_x = max(xs)\n\n    ys = [pos.y for pos in positions]\n    min_y = min(ys)\n    max_y = max(ys)\n\n    tile_representations = [\n        tuple(\n            tuple(Pos(i, j) in positions for j in range(min_y, max_y + 1))\n            for i in range(min_x, max_x + 1)\n        )\n    ]\n\n    for __ in range(3):\n        tile_representations.append(rotate90(tile_representations[-1]))\n\n    return min(tile_representations)\n\ndef get_tile_size(tile):\n    return sum(sum(row) for row in tile)\n\ndef parse_tiles(board, tile_value=1):\n    n = len(board)\n\n    # Add sentinel boundaries\n    sentinel = 1 - tile_value\n\n    board = [\n        [sentinel] * (n + 2),\n        *([sentinel] + row + [sentinel] for row in board),\n        [sentinel] * (n + 2),\n    ]\n\n    # Detect tiles\n    tile_positions = []\n    for i, j in product(range(1, n + 1), range(1, n + 1)):\n        if board[i][j] == tile_value:\n            stack = [Pos(i, j)]\n            squares = []\n            while stack:\n                curr = stack.pop()\n                board[curr.x][curr.y] = sentinel\n                squares.append(curr)\n                for neighbor in curr.neighbors():\n                    if board[neighbor.x][neighbor.y] == tile_value:\n                        stack.append(neighbor)\n            tile_positions.append(squares)\n\n    # Make tiles\n    tiles = [make_tile_from_positions(p) for p in tile_positions]\n\n    return tiles\n\ndef solution(game_board, table):\n    tiles = parse_tiles(table, 1)\n    empty_spaces = parse_tiles(game_board, 0)\n\n    tile_counter = Counter(tiles)\n    empty_space_counter = Counter(empty_spaces)\n\n    used_tiles = tile_counter &amp;amp; empty_space_counter\n\n    return sum(get_tile_size(tile) * occ for tile, occ in used_tiles.items())\n\n\n[2번 코드]\n\ndef dfs(table, i, j, shape, find = 1):\n        # 우 좌 하 상\n    dx = [0, 0, 1, -1]\n    dy = [1, -1, 0, 0] \n    stack = [[i, j]] # 현재 위치 스택에 저장\n    shape.append((i, j))\n    \n    while stack:\n        a, b = stack.pop()\n        table[a][b] = -1 # 방문 처리\n        for i in range(4): # 우 좌 하 상 순으로 스택에 저장 -&amp;gt; 상 하 좌 우 순으로 꺼내져 수행된다.\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 &amp;lt;= x &amp;lt; len(table) and 0 &amp;lt;= y &amp;lt; len(table[0]) and table[x][y] == find:\n                table[x][y] = -1\n                stack.append([x, y])\n                shape.append((x, y))\n                \n# 블록이나 빈 칸을 (0, 0)을 시작점으로 옮김\ndef rearrange(shape):\n    minX = min([x[1] for x in shape])\n    minY = min([x[0] for x in shape])\n    shape = [(s[0]-minY, s[1]-minX) for s in shape]\n    return sorted(shape) # 블록이 여러 칸으로 이루어진 경우 같은 모양에서 같은 결과를 위해 정렬해서 반환\n\n# 여러 방향으로 회전 후 하나의 값 반환\ndef rotate(shape):\n    if len(shape) == 1: return shape\n    shapes = []\n    shape = list(shape)\n    shape.sort()\n    width = max([x[1] for x in shape]) - min([x[1] for x in shape])\n    height = max([x[0] for x in shape]) - min([x[0] for x in shape])\n    # 시계 방향으로 4회 회전\n    for _ in range(4):\n        tmp = []\n        # 시계 방향으로 회전하는 방법\n        # 1. (x, y) 값을 (y, x)로 x, y를 맞바꾸는 &#39;전치&#39;\n        for pos in shape:\n            tmp.append((pos[1], pos[0])) # 전치\n        # 2. 전치된 결과에서 x 좌표를 가로 길이에서 뺀다.\n        tmp = [(x[0], width - x[1]) for x in tmp]\n        tmp = rearrange(tmp) # 재정렬\n        shape = tmp # 시계 방향으로 회전 한 블록을 shape에 다시 저장\n        shapes.append(shape)\n        width, height = height, width # 2x3 크기의 블록이 회전하면 3x2가 되므로 width, height를 맞바꾼다.\n    \n    # 4번 회전한 결과가 담긴 shapes의 최소값을 반환하면 \n    # 같은 구성의 순서가 다른 리스트에서도 항상 동일한 결과 반환\n    return min(shapes) \n                \ndef solution(game_board, table):\n    # table에서 추출된 블록들과 game_board에서 추출된 빈 칸들을 저장하는 리스트\n    shapes, spaces = list(), list() \n    # game_board와 table의 크기가 같다고 주어졌기 때문에 한 번에 돌릴 수 있음\n    for i in range(len(table[0])):\n        for j in range(len(table)):\n            # table에서 블록 추출하는 dfs\n            if table[i][j] == 1: # 1이면 블록\n                shape = list()\n                dfs(table, i, j, shape) # table에서 블록(1) 추출\n                shape = rearrange(shape) # 추출한 블록 (0, 0) 부터 시작하도록 위치 값 조정\n                shape = rotate(shape) # 회전 후 항상 동일한 결과 반환\n                shapes.append(shape) # shapes 에서 블록들 관리\n            # game_board에서 빈 칸 추출하는 dfs\n            if game_board[i][j] == 0: # 0이면 빈 칸\n                space = list()\n                dfs(game_board, i, j, space, find = 0) # game_board에서 빈 칸(0) 추출\n                space = rearrange(space) # 추출한 공백 (0, 0) 부터 시작하도록 위치 값 조정\n                space = rotate(space) # 회전 후 항상 동일한 결과 반환\n                spaces.append(space) # spaces 에서 공백들 관리\n                \n    answer = 0\n    for space in spaces:\n        for shape in shapes:\n            if space == shape: # 같은 모양이 있다면\n                answer += len(shape) # 블록의 개수만큼 더한다\n                shapes.remove(shape) # 사용된 블록은 제거\n                break\n    return answer\n\n"
} ,
  
  {
    "title"    : "[Python] 철학",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/2021/08/19/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%B2%A0%ED%95%99.html",
    "date"     : "August 19, 2021",
    "excerpt"  : "\n\n먼저 파이썬의 핵심 철학부터 살펴보겠습니다.\n\n- Beautiful is better than ugly. \n(아름다운 것이 추한 것보다 낫다)\n\n- Explicit is better than implicit.\n(명시적인 것이 암시적인 것보다 낫다.)\n\n- Simple is better than complex.\n(단순한 것이 복잡한 것보다 낫다.)\n\n- Complex is better than complicated.\n(복잡한 것이 난해한...",
  "content"  : "\n\n먼저 파이썬의 핵심 철학부터 살펴보겠습니다.\n\n- Beautiful is better than ugly. \n(아름다운 것이 추한 것보다 낫다)\n\n- Explicit is better than implicit.\n(명시적인 것이 암시적인 것보다 낫다.)\n\n- Simple is better than complex.\n(단순한 것이 복잡한 것보다 낫다.)\n\n- Complex is better than complicated.\n(복잡한 것이 난해한 것보다 낫다.)\n\n- Flat is better than nested.\n(단조로운 것이 뒤엉킨 것보다 낫다.)\n\n- Sparse is better than dense.\n(분포되어 있는 것이 빽빽한 것보다 낫다.)\n\n- Readability counts.\n(가독성은 중요하다.)\n\n\n나머지 파이썬의 철학입니다.\n\n- Special cases aren&#39;t special enough to break the rules.\n(특별한 경우라 하더라도 규칙을 어길 수 있을 만큼 특별하지 않다.)\n\n- Although practicality beats purity.\n(비록 실용성이 순수함을 앞선다 할지라도.)\n\n- Errors should never pass silently.\n(오류를 절대로 조용히 넘기면 안된다.)\n\n- Unless explicitly silenced.\n(분명하게 조용하지 않는한)\n\n- In the face of ambiguity, refuse the temptation to guess.\n(애매모호한 상황에서도 추측하려는 유혹을 떨쳐내야 한다.)\n\n- There should be one-- and preferably only one --obvious way to do it.\n(한 가지 방법이 있어야 한다. 그리고 가급적이면 그것을 할 수 있는 분명한 한 가지 방법이 있어야 한다.\n\n- Although that way may not be obvious at first unless you&#39;re Dutch.\n(비록 당신이 네덜란드 사람이 아니라면, 처음에 그 방법이 분명하지 않을 수도 있다.)\n→ 네덜란드 사람 = 파이썬 창시자\n\n- Now is better than never.\n(지금 하는 것이 하지 않는 것보다 낫다.)\n\n- Although never is often better than right now.\n(비록 하지 않는 것이 종종 지금 당장 하는 것보다 나을지라도.)\n\n- If the implementation is hard to explain, it&#39;s a bad idea.\n(만약 구현한 것이 설명하기 어렵다면, 그것은 나쁜 아이디어다.)\n\n- If the implementation is easy to explain, it may be a good idea.\n(만약 구현한 것이 설명하기 쉽다면, 그것은 좋은 아이디어일 것이다.)\n\n- Namespace are one honking great idea -- let&#39;s do more of those!\n(네임스페이스는 정말 좋은 아이디어다. 더 많이 사용하자!)\n\n\nEaster Egg\n\n&amp;gt;&amp;gt;&amp;gt; import this\n\n\n이스터 에그를 cli에 입력하면 파이썬 철학이 출력됩니다.\n\n\n\n\n  이 이스터 에그는 파이썬에 많은 기여를 한 팀 피터스(Tim Peters)가 추가해둔 것이라고 합니다.\n\n  Reference - [Python doc]\n\n"
} ,
  
  {
    "title"    : "[Python] collections 라이브러리",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/2021/08/15/collections.html",
    "date"     : "August 15, 2021",
    "excerpt"  : "\n\ncollections 는 Python의 내장 라이브러리로 컨테이너 데이터형 의 구현 및 활용을 도와주는 라이브러리입니다.\n\ncollections 의 주요 객체를 살펴보면 아래와 같습니다.\n\n\n  \n    \n      객체\n      설명\n    \n  \n  \n    \n      namedtuple\n      이름 붙은 필드를 갖는 튜플 서브 클래스를 만들기 위한 팩토리 함수\n    \n    \n      deque\n      양쪽 끝에서 ...",
  "content"  : "\n\ncollections 는 Python의 내장 라이브러리로 컨테이너 데이터형 의 구현 및 활용을 도와주는 라이브러리입니다.\n\ncollections 의 주요 객체를 살펴보면 아래와 같습니다.\n\n\n  \n    \n      객체\n      설명\n    \n  \n  \n    \n      namedtuple\n      이름 붙은 필드를 갖는 튜플 서브 클래스를 만들기 위한 팩토리 함수\n    \n    \n      deque\n      양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너\n    \n    \n      ChainMap\n      여러 매핑의 단일 뷰를 만드는 딕셔너리류 클래스\n    \n    \n      Counter\n      해시 가능한 객체를 세는 데 사용하는 딕셔너리 서브 클래스\n    \n    \n      OrderedDict\n      항목이 추가된 순서를 기억하는 딕셔너리 서브 클래스\n    \n    \n      defaultdict\n      누락된 값을 제공하기 위해 팩토리 함수를 호출하는 딕셔너리 서브 클래스\n    \n  \n\n\n\n  namedtuple\n  deque\n  ChainMap\n  Counter\n  OrderedDict\n  defaultdict\n\n\nnamedtuple\n\n이름 그대로 튜플(값)에 이름(키)을 붙이는 데이터 구조입니다.\n\n먼저 간단하게 사용 방법을 보겠습니다.\n\nfrom collections import namedtuple\n\n# namedtuple 선언부분, []안에 이름(키)을 선언\nComputer = namedtuple(&#39;Computer&#39;, [&#39;cpu&#39;, &#39;ram&#39;, &#39;ssd&#39;])\n# 아래의 방식으로 이름(키) 선언 가능\nComputer = namedtuple(&#39;Computer&#39;, &#39;cpu ram ssd&#39;)\n\n# Computer라는 namedtuple 객체를 통해 데이터를 할당하여, com_100 인스턴스 생성\ncom_100 = Computer(cpu=&#39;i5&#39;, ram=8, ssd=1024)\n\n# com_200 생성\ncom_200 = Computer(cpu=&#39;i7&#39;, ram=16, ssd=2048)\n\nprint(f&#39;com_100 [type: {type(com_100)} / data: {com_100}]&#39;)\nprint(f&#39;com_200 [type: {type(com_200)} / data: {com_200}]&#39;)\n---------------------------------------------------\n&quot;com_100 [type: &amp;lt;class &#39;__main__.Computer&#39;&amp;gt; / data: Computer(cpu=&#39;i5&#39;, ram=8, ssd=1024)]&quot;\n&quot;com_200 [type: &amp;lt;class &#39;__main__.Computer&#39;&amp;gt; / data: Computer(cpu=&#39;i7&#39;, ram=16, ssd=2048)]&quot;\n\n\n출력된 결과를 보면 타입이 namedtuple로 선언된 객체인 Computer 로 나오는 것을 볼 수 있습니다.\n\n아래는 namedtuple 와 관련된 추가적인 내용입니다.\n\n# 출력부만 변경\n# 이름(키)을 통해서 해당되는 데이터를 호출할 수 있다.\nprint(f&#39;com_100 [ssd: {com_100.ssd}]&#39;)\nprint(f&#39;com_200 [cpu: {com_100.cpu}]&#39;)\n---------------------------------------------------\n&quot;com_100 [ssd: 1024]&quot;\n&quot;com_200 [cpu: i5]&quot;\n\n# _make(iterable)\namd = [&#39;amd 5600x&#39;, 16, 2048]\ncom_amd_make = Computer._make(amd)\nprint(com_amd_make)\n---------------------------------------------------\n&quot;Computer(cpu=&#39;amd 5600x&#39;, ram=16, ssd=2048)&quot;\n\n# _fields\nprint(com_100._fields)\n---------------------------------------------------\n&quot;(&#39;cpu&#39;, &#39;ram&#39;, &#39;ssd&#39;)&quot;\n\n# _field_defaults\n# -&amp;gt; default값은 뒷쪽부터 채워짐\n# -&amp;gt; 인스턴스 생성시 입력값은 앞쪽부터 채워짐\nDefault_Computer = namedtuple(&#39;Default_Computer&#39;, [&#39;cpu&#39;, &#39;ram&#39;, &#39;ssd&#39;], defaults=[4, 1024])\ncom_100 = Default_Computer(&#39;i3&#39;)\ncom_200 = Default_Computer(&#39;i5&#39;)\n\n# default로 설정된 값 확인\nprint(Default_Computer._field_defaults)\nprint(f&#39;com_100: {com_100}&#39;)\nprint(f&#39;com_200: {com_200}&#39;)\n---------------------------------------------------\n&quot;{&#39;ram&#39;: 4, &#39;ssd&#39;: 1024}&quot;\n&quot;com_100: Default_Computer(cpu=&#39;i3&#39;, ram=4, ssd=1024)&quot;\n&quot;com_200: Default_Computer(cpu=&#39;i5&#39;, ram=4, ssd=1024)&quot;\n\n# namedtuple은 class로 취급되기 때문에,\n# 서브 클래스를 사용하여 기능을 추가, 변경할 수 있다.\nclass Computer(namedtuple(&#39;Computer&#39;, [&#39;cpu&#39;, &#39;ram&#39;, &#39;ssd&#39;])):\n    __slots__ = ()\n    def __str__(self):\n        # 출력 형태를 재선언하여 변경\n        return f&#39;Computer[cpu: {self.cpu}|ram: {self.ram}|ssd: {self.ssd}]&#39;\n\ncom_test1 = Computer(&#39;i3&#39;, 4, 1024)\ncom_test2 = Computer(&#39;i5&#39;, 8, 2048)\nprint(com_test1)\nprint(com_test2)\n---------------------------------------------------\n&quot;Computer[cpu: i3|ram: 4|ssd: 1024]&quot;\n&quot;Computer[cpu: i5|ram: 8|ssd: 2048]&quot;\n\n\ndeque\n\ndeque는 스택과 큐를 일반화 한 것입니다.\n\nDouble Ended Queue의 약자입니다.\n\n데이터의 삽입과 삭제가 양쪽에서 모두 가능한 자료구조입니다.\n\n아래의 함수를 통해 활용이 가능합니다.\n\n\n  \n    \n      함수\n      설명\n    \n  \n  \n    \n      append(x)\n      deque 오른쪽에 x를 추가\n    \n    \n      appendleft(x)\n      deque 왼쪽에 x를 추가\n    \n    \n      clear()\n      deque에서 모든 요소를 제거하고 길이가 0인 상태로 만듬\n    \n    \n      copy()\n      deque의 얕은 복사본을 만듬\n    \n    \n      count(x)\n      x와 같은 요소의 갯수를 반환\n    \n    \n      extend(iterable)\n      iterable 인자의 요소를 추가하여 deque의 오른쪽을 확장\n    \n    \n      index(x, start, stop)\n      deque에 있는 x의 위치를 반환 (start 이후, stop 이전 - 필수 아님), 반환할 수 없는 경우 ValueError 발생\n    \n    \n      pop()\n      deque의 오른쪽에서 요소를 제거하고 반환, 요소가 없으면 IndexError 발생\n    \n    \n      popleft()\n      deque의 왼쪽에서 요소를 제거하고 반환, 요소가 없으면 IndexError 발생\n    \n    \n      remove(value)\n      value의 첫 번째 항목을 제거, 찾을 수 없으면 ValueError 발생\n    \n    \n      reverse()\n      deque 요소들의 순서를 뒤집기, 원본 데이터가 변형\n    \n    \n      rotate(n=1)\n      deque를 n단계 오른쪽으로 회전, n이 음수면 왼쪽으로 회전 → dq.rotate(n=1) == dq.appendleft(dq.pop()) → dq.rotate(n=-1) == dq.append(dq.popleft())\n    \n    \n      maxlen\n      deque의 최대 크기 or None 반환\n    \n  \n\n\nChainMap\n\n맵 여러 개를 합쳐서 중복을 제외하고 하나의 dictionary로 만들어주는 자료구조입니다.\n\n중복된 데이터는 첫 번째 인자로 입력된 맵의 데이터를 남겨두고 나머지는 제외합니다.\n\nMap 형태의 데이터를 인자로 받아서 선언합니다.\n\nfrom collections import ChainMap\n\na = {1: &#39;a&#39;, 3: &#39;c1&#39;}\nb = {2: &#39;b&#39;, 3: &#39;c2&#39;}\n\n# 선언\ncm = ChainMap(a, b)\nprint(cm)\nprint(list(cm.keys()))\nprint(list(cm.values()))\n---------------------------------------------------\n&quot;ChainMap({1: &#39;a&#39;, 3: &#39;c1&#39;}, {2: &#39;b&#39;, 3: &#39;c2&#39;})&quot;\n&quot;[2, 3, 1]&quot;\n&quot;[&#39;b&#39;, &#39;c1&#39;, &#39;a&#39;]&quot;\n\n\nCounter\n\n요소와 요소의 갯수로 “키-값“의 형태를 같는 해시 가능한 dictionary 서브 클래스입니다.\n\n기본적으로 특정 요소의 갯수를 셀 때 사용합니다.\n\n아래의 코드를 보면 4가지 형태의 선언 방식을 사용할 수 있습니다.\n\nfrom collections import Counter\n\n# Counter 객체의 인스턴스 생성\nc = Counter()\nc = Counter(&#39;word test&#39;)\nc = Counter({&#39;red&#39;: 4, &#39;blue&#39;: 2})\nc = Counter(red=4, blue=2)\n\n\nkey 값에 갯수 확인을 원하는 요소를 넣으면 갯수를 확인할 수 있다.\n\nfrom collections import Counter\n\nc = Counter([&#39;red&#39;, &#39;blue&#39;])\nprint(f&quot;red: {c[&#39;red&#39;]}&quot;)\nprint(f&quot;green: {c[&#39;green&#39;]}&quot;)\n---------------------------------------------------\n&quot;red: 1&quot;\n&quot;green: 0&quot;\n\n\n아래는 함수를 통해 사용할 수 있는 기능입니다.\n\nfrom collections import Counter\n\n# elements() -&amp;gt; iter의 형태로 요소들을 반환\nc = Counter(a=2, b=3, c=0, d=1)\nprint(c.elements())\nprint(sorted(c.elements()))\n---------------------------------------------------\n&quot;&amp;lt;itertools.chain object at 0x7ffe51242040&amp;gt;&quot;\n&quot;[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;d&#39;]&quot;\n\n# most_common([n]) -&amp;gt; 갯수가 가장 많은 요소부터 n개 출력\nc = Counter(&#39;abracadabra&#39;).most_common(3)\nprint(c)\n---------------------------------------------------\n&quot;[(&#39;a&#39;, 5), (&#39;b&#39;, 2), (&#39;r&#39;, 2)]&quot;\n\n# update([iterable-or-mapping]) -&amp;gt; 요소들의 합을 연산 (원본 데이터 변경)\nc3 = Counter(a=3, b=2, c=1)\nc4 = Counter(a=1, b=2, c=3)\nc3.update(c4)\nprint(c3)\n---------------------------------------------------\n&quot;Counter({&#39;a&#39;: 4, &#39;b&#39;: 4, &#39;c&#39;: 4})&quot;\n\n# subtract([iterable-or-mapping]) -&amp;gt; 요소들의 차를 연산 (원본 데이터 변경)\nc1 = Counter(a=3, b=2, c=1)\nc2 = Counter(a=1, b=2, c=3)\nc1.subtract(c2)\nprint(c1)\n---------------------------------------------------\n&quot;Counter({&#39;a&#39;: 2, &#39;b&#39;: 0, &#39;c&#39;: -2})&quot;\n\n\nOrderedDict\n\n\n  Python 3.7 이후부터 기본 dictionary에서도 데이터 입력 순서가 보존되기 때문에 활용성이 약간 감소되었습니다.\n\n  “Python - Dictionary”\n\n\n현재 일반 dictionary 객체와의 차이는 데이터의 순서를 바꾸는 연산에 적합하다는 차이만 가지고 있습니다.\n\n아래는 순서를 변경할 때 사용하는 함수입니다.\n\nfrom collections import OrderedDict\n\n# move_to_end(key, last=True) -&amp;gt; last가 False이면 왼쪽 끝으로 이동\nd = OrderedDict.fromkeys(&#39;abcde&#39;)\nd.move_to_end(&#39;c&#39;)\nprint(f&#39;True: {d}&#39;)\n---------------------------------------------------\n&quot;True: OrderedDict([(&#39;a&#39;, None), (&#39;b&#39;, None), (&#39;d&#39;, None), (&#39;e&#39;, None), (&#39;c&#39;, None)])&quot;\n\nd.move_to_end(&#39;c&#39;, False)\nprint(f&#39;False: {d}&#39;)\n---------------------------------------------------\n&quot;False: OrderedDict([(&#39;c&#39;, None), (&#39;a&#39;, None), (&#39;b&#39;, None), (&#39;d&#39;, None), (&#39;e&#39;, None)])&quot;\n\n# popitem(last=True) -&amp;gt; last가 True면 LIFO, False이면 FIFO 순서로 반환\nd = OrderedDict.fromkeys(&#39;abcde&#39;)\nk, v = d.popitem()\nprint(f&#39;True: {k, v}&#39;)\nprint(d)\n---------------------------------------------------\n&quot;True: (&#39;e&#39;, None)&quot;\n&quot;OrderedDict([(&#39;a&#39;, None), (&#39;b&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None)])&quot;\n\nk, v = d.popitem(False)\nprint(f&#39;False: {k, v}&#39;)\nprint(d)\n---------------------------------------------------\n&quot;False: (&#39;a&#39;, None)&quot;\n&quot;OrderedDict([(&#39;b&#39;, None), (&#39;c&#39;, None), (&#39;d&#39;, None)])&quot;\n\n\ndefaultdict\n\ndictionary value의 초깃값을 설정합니다.\n\nfrom collections import defaultdict\n\ndefault_list = defaultdict(list)\ndefault_list[1]\ndefault_list[2]\nprint(f&#39;default_list: {default_list}&#39;)\n---------------------------------------------------\n&quot;default_list: defaultdict(&amp;lt;class &#39;list&#39;&amp;gt;, {1: [], 2: []})&quot;\n\ndefault_dict = defaultdict(dict)\ndefault_dict[1]\ndefault_dict[2]\nprint(f&#39;default_dict: {default_dict}&#39;)\n---------------------------------------------------\n&quot;default_dict: defaultdict(&amp;lt;class &#39;dict&#39;&amp;gt;, {1: {}, 2: {}})&quot;\n\n\n\n  “Python 3.9.6 Documentation - collections\n\n"
} ,
  
  {
    "title"    : "[프로그래머스] 음양 더하기",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/14/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9D%8C%EC%96%91-%EB%8D%94%ED%95%98%EA%B8%B0.html",
    "date"     : "August 14, 2021",
    "excerpt"  : "\n\n프로그래머스 “음양 더하기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.\n\n\n\n제한사항\n\n\n  absolutes의 길이는 1 이상 1...",
  "content"  : "\n\n프로그래머스 “음양 더하기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.\n\n\n\n제한사항\n\n\n  absolutes의 길이는 1 이상 1,000 이하입니다.\n    \n      absolutes의 모든 수는 각각 1 이상 1,000 이하입니다.\n    \n  \n  signs의 길이는 absolutes의 길이와 같습니다.\n    \n      signs[i] 가 참이면 absolutes[i] 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.\n    \n  \n\n\n\n\n입출력 예\n\n\n  \n    \n      absolutes\n      signs\n      result\n    \n  \n  \n    \n      [4,7,12]\n      [true,false,true]\n      9\n    \n    \n      [1,2,3]\n      [false,false,true]\n      0\n    \n  \n\n\n\n\n입출력 예 설명\n\n입출력 예 #1\n\n\n  signs가 [true,false,true] 이므로, 실제 수들의 값은 각각 4, -7, 12입니다.\n  따라서 세 수의 합인 9를 return 해야 합니다.\n\n\n입출력 예 #2\n\n\n  signs가 [false,false,true] 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다.\n  따라서 세 수의 합인 0을 return 해야 합니다.\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  absolutes, signs 2개 리스트의 요소를 동시에 꺼내서 계산을 진행하면 빠르게 끝낼 수 있다고 생각\n  이전의 내적 문제와 유사하다고 생각\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\ndef solution(absolutes, signs):\n    answer = sum([num if s else -num for num, s in zip(absolutes, signs)])\n    return answer\n\n\n[여담]\n\n오늘은 1년에 하루뿐인 날이지만, 오늘도 짧게나마 공부했습니다.\n"
} ,
  
  {
    "title"    : "[프로그래머스] 내적",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/13/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%82%B4%EC%A0%81.html",
    "date"     : "August 13, 2021",
    "excerpt"  : "\n\n프로그래머스 “내적” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요.\n\n이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + ... + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이)\n\n\n\n제한사항\n\n\n  a, b의 길이는 1...",
  "content"  : "\n\n프로그래머스 “내적” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요.\n\n이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + ... + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이)\n\n\n\n제한사항\n\n\n  a, b의 길이는 1 이상 1,000 이하입니다.\n  a, b의 모든 수는 -1,000 이상 1,000 이하입니다.\n\n\n\n\n입출력 예\n\n\n  \n    \n      a\n      b\n      result\n    \n  \n  \n    \n      [1,2,3,4]\n      [-3,-1,0,2]\n      3\n    \n    \n      [-1,0,1]\n      [1,0,-1]\n      -2\n    \n  \n\n\n\n\n입출력 예 설명\n\n입출력 예 #1\n\n\n  a와 b의 내적은 1*(-3) + 2*(-1) + 3*0 + 4*2 = 3 입니다.\n\n\n입출력 예 #2\n\n\n  a와 b의 내적은 (-1)*1 + 0*0 + 1*(-1) = -2 입니다.\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  a, b 2개 리스트의 요소를 동시에 꺼내서 계산을 진행하면 빠르게 끝낼 수 있다고 생각했습니다.\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\ndef solution(a, b):\n    # zip() 함수를 통해 2개 리스트의 요소를 동시에 추출하여 계산\n    answer = sum([small_a * small_b for small_a, small_b in zip(a, b)])\n    return answer\n\n\n[여담]\n\n내적이라는 것이 무언인지 궁금해서 찾아봤습니다.\n\n\n  내적이란 스칼라 곱이라고도 하며, 여기서 스칼라는 크기만 있고 방향은 가지지 않는 양이다. 즉, 방향이 있는 두 개의 벡터 값의 스칼라를 계산하는 것을 뜻한다. 주로 두 벡터 간의 각도를 구하기 위해 사용된다.\n\n  두 벡터 a와 b의 스칼라 곱은 a·b=|a|·|b|cosθ로 표현하며, 이것은 벡터a와 벡터b의 방향을 동일한 방향으로 변환하여 곱해 주는 것이다. 예를 들어 벡터 a와 벡터 b 사이의 θ값이 90˚일 경우 스칼라 곱은 0이 되고, 0인 경우 같은 방향이라는 의미로 최댓값이 나온다.\n\n  ※ 내적의 성질\n\n  \n    교환법칙이 성립한다.\n    결합법칙이 성립한다.\n    배분법칙이 성립한다.\n  \n\n  “사이언스올 - 내적”\n\n\n복잡한 수학적 의미가 담긴 내용이었습니다.\n\n내적에 대한 내용을 쉽게 정리하면 벡터와 벡터의 곱연산 -&amp;gt; 결과는 스칼라 입니다.\n\n\\[a * b = a_1b_1 + a_2b_2 + ... + a_nb_n\\]\n\n즉, a * b의 의미로 볼 수 있었다. (많은 내용이 함축되고 생략됨)\n\n\n  📌 보통은 “벡터+벡터=벡터”, “스칼라+스칼라=스칼라” 라고 합니다.\n\n"
} ,
  
  {
    "title"    : "[프로그래머스] 상호 평가",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/12/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9C%84%ED%81%B4%EB%A6%AC-%EC%B1%8C%EB%A6%B0%EC%A7%80-2%EC%A3%BC%EC%B0%A8.html",
    "date"     : "August 12, 2021",
    "excerpt"  : "\n\n프로그래머스 위클리 챌린지 2주차 “상호 평가” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.\n\n\n  \n    \n      No.\n      0\n      1\n      2\n      3\n     ...",
  "content"  : "\n\n프로그래머스 위클리 챌린지 2주차 “상호 평가” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.\n\n\n  \n    \n      No.\n      0\n      1\n      2\n      3\n      4\n    \n  \n  \n    \n      0\n      100(제외)\n      90\n      98\n      88\n      65\n    \n    \n      1\n      50\n      45(제외)\n      99\n      85\n      77\n    \n    \n      2\n      47\n      88\n      95\n      80\n      67\n    \n    \n      3\n      61\n      57\n      100\n      80\n      65\n    \n    \n      4\n      24\n      90\n      94\n      75\n      65\n    \n    \n      평균\n      45.5\n      81.25\n      97.2\n      81.6\n      67.8\n    \n    \n      학점\n      F\n      B\n      A\n      B\n      D\n    \n  \n\n\n위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.\n\n\n  0번 학생이 평가한 점수는 0번 행에담긴 [100, 90, 98, 88, 65]입니다.\n    \n      0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.\n    \n  \n  2번 학생이 평가한 점수는 2번 행에담긴 [47, 88, 95, 80, 67]입니다.\n    \n      2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.\n    \n  \n\n\n당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.\n\n\n  0번 학생이 받은 점수는 0번 열에 담긴 [100, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.\n    \n      0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.\n    \n  \n  4번 학생이 받은 점수는 4번 열에 담긴 [65, 77, 67, 65, 65]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다.\n    \n      4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.\n    \n  \n\n\n제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.\n\n\n  \n    \n      평균\n      학점\n    \n  \n  \n    \n      90점 이상\n      A\n    \n    \n      80점 이상 90점 미만\n      B\n    \n    \n      70점 이상 80점 미만\n      C\n    \n    \n      50점 이상 70점 미만\n      D\n    \n    \n      50점 미만\n      F\n    \n  \n\n\n학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.\n\n\n\n제한사항\n\n\n  2 ≤ scores의 행의 길이(학생 수) ≤ 10\n  scores의 열의 길이 = scores의 행의 길이\n    \n      즉, scores는 행과 열의 길이가 같은 2차원 배열입니다.\n    \n  \n  0 ≤ scores의 원소 ≤ 100\n  return 값 형식\n    \n      0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.\n    \n  \n\n\n\n\n입출력 예\n\n\n  \n    \n      scores\n      result\n    \n  \n  \n    \n      [[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]\n      “FBABD”\n    \n    \n      [[50,90],[50,87]]\n      “DA”\n    \n    \n      [[70,49,90],[68,50,38],[73,31,100]]\n      “CFD”\n    \n  \n\n\n\n\n입출력 예 설명\n\n입출력 예 #1\n\n문제 예시와 같습니다.\n\n입출력 예 #2\n\n\n  \n    \n      No.\n      0\n      1\n    \n  \n  \n    \n      0\n      50\n      90\n    \n    \n      1\n      50\n      87(제외)\n    \n    \n      평균\n      50\n      90\n    \n    \n      학점\n      D\n      A\n    \n  \n\n\n\n  1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.\n\n\n입출력 예 #3\n\n\n  \n    \n      No.\n      0\n      1\n      2\n    \n  \n  \n    \n      0\n      70\n      49\n      90\n    \n    \n      1\n      68\n      50(제외)\n      38\n    \n    \n      2\n      73\n      31\n      100(제외)\n    \n    \n      평균\n      70.33…\n      40\n      64\n    \n    \n      학점\n      C\n      F\n      D\n    \n  \n\n\n\n  1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.\n  2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  2차원 배열을 재배열\n  2차원 배열 데이터로 평균 계산\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\ndef solution(scores):\n    # 하단의 조건문 생략 풀이를 위한 등급 변수 선언\n    grade = &#39;FFDCBAA&#39;\n    answer = list()\n    # 2차원 배열 재배열\n    for i, score in enumerate(zip(*scores)):\n        # 자신이 부여한 점수\n        self_score = score[i]\n        # 다른 사람이 부여한 점수\n        other_score = score[:i] + score[i+1:]\n\n        # 최소, 최대 값으로 self_score가 일치하면 self_score를 계산에서 제외\n        if min(score) &amp;lt;= self_score &amp;lt;= max(score):\n            valid_score = other_score\n        else:\n            valid_score = [self_score, *other_score]\n\n        avg = sum(valid_score) / len(valid_score)\n\n        # 일반적인 조건문 풀이 방식\n        # grade = &#39;F&#39;\n        # if 90 &amp;lt;= avg:\n        #     grade = &#39;A&#39;\n        # elif 80 &amp;lt;= avg &amp;lt; 90:\n        #     grade = &#39;B&#39;\n        # elif 70 &amp;lt;= avg &amp;lt; 80:\n        #     grade = &#39;C&#39;\n        # elif 50 &amp;lt;= avg &amp;lt; 70:\n        #     grade = &#39;D&#39;\n        # answer.append(grade)\n\n        # 조건문 생략 풀이\n        # 10의 자리를 이용하여 grade 문자열에서 등급 추출하는 방식\n        # 9x ~ 100 -&amp;gt; 5, 6번 인덱스\n        # 8x ~     -&amp;gt; 4\n        # 7x ~     -&amp;gt; 3\n        # 5x ~ 6x  -&amp;gt; 1, 2\n        # 0 ~ 4x   -&amp;gt; 0\n        grade_idx = max(int(avg / 10) - 4, 0)\n        answer.append(grade[grade_idx])\n\n    return &#39;&#39;.join(answer)\n\n\n[여담]\n\n등급을 구하는 조건문을 최소화하는 방법을 생각해보다가 위의 코드를 구현하게 됐습니다.\n\n조건문 생략 풀이가 파이썬스러운 코드같다.\n"
} ,
  
  {
    "title"    : "[프로그래머스] 부족한 금액 계산하기",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/12/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9C%84%ED%81%B4%EB%A6%AC-%EC%B1%8C%EB%A6%B0%EC%A7%80-1%EC%A3%BC%EC%B0%A8.html",
    "date"     : "August 12, 2021",
    "excerpt"  : "\n\n프로그래머스 위클리 챌린지 1주차 “로또의 최고 순위와 최저 순위” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다....",
  "content"  : "\n\n프로그래머스 위클리 챌린지 1주차 “로또의 최고 순위와 최저 순위” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.단, 금액이 부족하지 않으면 0을 return 하세요.\n\n제한사항\n\n\n  놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수\n  처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수\n  놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수\n\n\n\n\n입출력 예\n\n\n  \n    \n      price\n      money\n      count\n      result\n    \n  \n  \n    \n      3\n      20\n      4\n      10\n    \n  \n\n\n입출력 예 설명\n\n입출력 예 #1이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.\n\n참고 사항\n\n\n  미션 언어는 Java, JavaScript, Python3, C++ 만 해당 됩니다.\n  같은 코드를 제출한 사람이 여럿이라면 코드를 가장 먼저 제출한 분께 상품을 드립니다.\n  좋아요 수가 동일할 경우 코드를 가장 먼저 제출한 분께 상품을 드립니다.\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  반복을 통해 숫자 계산을 하는 아주 간단한 문제\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[재귀 풀이 코드]\n\nimport sys\n# Python 재귀 제한 해제\nsys.setrecursionlimit(10**6)\n\ndef solution(price, money, count):\n    # 재귀를 사용하여 금액을 계산\n    def calMoney(count):\n        nonlocal money\n        if count &amp;gt; 0:\n            money -= (price * count)\n            print(money)\n            return calMoney(count-1)\n        else:\n            return money\n    \n    answer = calMoney(count)\n    \n    return abs(answer) if answer &amp;lt; 0 else 0\n\n\n[여담]\n\n얼마전 재귀 문제를 좀 힘들게 풀었던 기억이 있어서 간단하지만 재귀로 풀어봤습니다.\n\n아래는 얼마전 경험이 없었으면 푸는 스타일\n\n[원래 스타일 코드]\n\n귀찮은 것을 굉장히 싫어하는 스타일\n\ndef solution(price, money, count):\n    # price를 곱한 등차수열을 계산\n    answer = (price * (count + 1) * count // 2) - money\n    return max(0, answer)\n\n\n문제는 price 크기만큼 커진 등차수열을 구하는 문제였기 때문에 수식을 사용하면 쉽게 해결이 가능합니다.\n"
} ,
  
  {
    "title"    : "[백준 11729번] 하노이 탑 이동 순서",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/11/%EB%B0%B1%EC%A4%80-11729%EB%B2%88.html",
    "date"     : "August 11, 2021",
    "excerpt"  : "\n\n백준 “하노이 탑 이동 순서” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n\n\n  한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.\n  쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야...",
  "content"  : "\n\n백준 “하노이 탑 이동 순서” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n\n\n  한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.\n  쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.\n\n\n이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.\n\n아래 그림은 원판이 5개인 경우의 예시이다.\n\n\n\n입력\n\n첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.\n\n출력\n\n첫째 줄에 옮긴 횟수 K를 출력한다.\n\n두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.\n\n예제 입력 1\n\n3\n\n\n예제 출력 1\n\n7\n1 3\n1 2\n3 2\n1 3\n2 1\n2 3\n1 3\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  마지막 원판을 목표자리로 옮기기 위해서는 마지막 원판부터 1번째 원판까지 경로를 재귀로 풀어야겠다고 생각\n→ 처리하는 원판 순서 : n → n -1 → n -2 … → 1\n  K를 구하는 규칙은 2^n - 1 식을 이용하면 될 것 같음\n→ 총 이동 횟수\n  이동하는 장소가 3개로 제한적이라 장소를 가지고 연산\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport sys\ninput = sys.stdin.readline\n\ndef hanoi(n, x, y, z):\n    # 총 원판이 1개인 경우는 이동 경로가 1가지라 바로 반환\n    if n == 1:\n        print(x, z)\n    else:\n        # n원판이 3번 자리로 가야 하기 때문에 n-1번 원판은 2번 자리로 이동\n        hanoi(n-1, x, z, y)\n        print(x, z)\n        # n-1번 원판이 n번 원판 위에 올라가야 하기 때문에 3번 자리로 이동\n        hanoi(n-1, y, x, z)\n\nif __name__ == &#39;__main__&#39;:\n    N = int(input())\n    # 2의 n승 -1 -&amp;gt; 원판 총 이동 횟수\n    K = (2**N) - 1\n    print(K)\n    hanoi(N, 1, 2, 3)\n\n\n[여담]\n\n재귀는 복잡하거나 반복적인 것을 참 단순하게 표현할 수 있어서 좋습니다.\n\n하지만 복잡한 것을 단순하게 보여줘서 내용을 머리에서 떠올려보기가 좀 어렵습니다.\n\n아래는 데코레이터 의 엄청난 성능을 볼 수 있었던 코드입니다.\n\n[데코레이터 코드]\nimport sys\ninput = sys.stdin.readline\n\n# dictionary 구조에 출력할 데이터를 저장하는 데코레이터\ndef cacheable(func):\n    cache = {}\n\n    def u(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n\n    return u\n\n@cacheable\ndef hanoi_cache(n, s=1, e=3):\n    # n이 0인 경우는 이동이 없으므로 &#39;&#39;\n    if n == 0:\n        return &#39;&#39;\n    # 마지막에 1번의 출력을 위한 경로를 담기위한 리스트\n    res = []\n    # 2번과 3번 자리를 표현한 것 같음\n    t = 6 - s - e\n    # 위 코드의 hanoi(n-1, x, z, y)와 동일한 역할\n    res.append(hanoi_cache(n - 1, s, t))\n    # 경로 이동 과정\n    res.append(f&#39;{s} {e}\\n&#39;)\n    # 위 코드의 hanoi(n-1, y, x, z)와 동일한 역할\n    res.append(hanoi_cache(n - 1, t, e))\n\n    # 리스트에 담아뒀던 경로를 하나의 문자열로 합치기\n    return &#39;&#39;.join(res)\n\nif __name__ == &#39;__main__&#39;:\n    n = int(input())\n    print(2 ** n - 1)\n    print(hanoi_cache(n))\n\n\nprint() 함수가 생각보다 많은 리소스를 사용하는 것을 알고 있었습니다.\n\n그렇기에 이 코드는 정말 제대로라는 생각이 들었습니다.\n\n\n  janos 코드 실행시간 → 936ms\n데코레이터 를 활용한 코드 실행시간 → 92ms\n\n\n출력을 최소화하여 10배 가량의 성능 차이를 보였습니다.\n\n대박\n"
} ,
  
  {
    "title"    : "[프로그래머스] 로또의 최고 순위와 최저 순위",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/10/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%A1%9C%EB%98%90%EC%9D%98-%EC%B5%9C%EA%B3%A0-%EC%88%9C%EC%9C%84%EC%99%80-%EC%B5%9C%EC%A0%80-%EC%88%9C%EC%9C%84.html",
    "date"     : "August 10, 2021",
    "excerpt"  : "\n\n프로그래머스 “로또의 최고 순위와 최저 순위” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n로또 6/45(이하 ‘로또’로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다.\n\n\n  \n    \n      순위\n      당첨 내용\n    \n  \n  \n    \n      1\n      6개 번호가 모두 일치\n    \n    ...",
  "content"  : "\n\n프로그래머스 “로또의 최고 순위와 최저 순위” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n로또 6/45(이하 ‘로또’로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다.\n\n\n  \n    \n      순위\n      당첨 내용\n    \n  \n  \n    \n      1\n      6개 번호가 모두 일치\n    \n    \n      2\n      5개 번호가 일치\n    \n    \n      3\n      4개 번호가 일치\n    \n    \n      4\n      3개 번호가 일치\n    \n    \n      5\n      2개 번호가 일치\n    \n    \n      6(낙첨)\n      그 외\n    \n  \n\n\n로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.알아볼 수 없는 번호를 0으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 44, 1, 0, 0, 31 25라고 가정해보겠습니다. 당첨 번호 6개가 31, 10, 45, 1, 6, 19라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다.\n\n\n  \n    \n      당첨 번호\n      31\n      10\n      45\n      1\n      6\n      19\n      결과\n    \n  \n  \n    \n      최고 순위 번호\n      31\n      0→10\n      44\n      1\n      0→6\n      25\n      4개 번호 일치, 3등\n    \n    \n      최저 순위 번호\n      31\n      0→11\n      44\n      1\n      0→7\n      25\n      2개 번호 일치, 5등\n    \n  \n\n\n\n  순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.\n  알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.\n    \n      3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.\n    \n  \n  알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.\n    \n      5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.\n    \n  \n\n\n민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.\n\n제한사항\n\n\n  lottos는 길이 6인 정수 배열입니다.\n  lottos의 모든 원소는 0 이상 45 이하인 정수입니다.\n    \n      0은 알아볼 수 없는 숫자를 의미합니다.\n      0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다.\n      lottos의 원소들은 정렬되어 있지 않을 수도 있습니다.\n    \n  \n  win_nums은 길이 6인 정수 배열입니다.\n  win_nums의 모든 원소는 1 이상 45 이하인 정수입니다.\n    \n      win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다.\n      win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.\n    \n  \n\n\n\n\n입출력 예\n\n\n  \n    \n      lottos\n      win_nums\n      result\n    \n  \n  \n    \n      [44, 1, 0, 0, 31, 25]\n      [31, 10, 45, 1, 6, 19]\n      [3, 5]\n    \n    \n      [0, 0, 0, 0, 0, 0]\n      [38, 19, 20, 40, 15, 25]\n      [1, 6]\n    \n    \n      [45, 4, 35, 20, 3, 9]\n      [20, 9, 3, 45, 4, 35]\n      [1, 1]\n    \n  \n\n\n입출력 예 설명\n\n입출력 예 #1문제 예시와 같습니다.\n\n입출력 예 #2알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다.\n\n\n  \n    \n      당첨 번호\n      38\n      19\n      20\n      40\n      15\n      25\n      결과\n    \n  \n  \n    \n      최고 순위 번호\n      0→38\n      0→19\n      0→20\n      0→40\n      0→15\n      0→25\n      6개 번호 일치, 1등\n    \n    \n      최저 순위 번호\n      0→21\n      0→22\n      0→23\n      0→24\n      0→26\n      0→27\n      0개 번호 일치, 6등\n    \n  \n\n\n입출력 예 #3민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.\n\n\n\n\n  실제로 사용되는 로또 순위의 결정 방식과는 약간 다르지만, 이 문제에서는 지문에 명시된 대로 로또 순위를 결정하도록 합니다.\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  0의 개수와 나머지 숫자들만 비교하면 쉽게 답을 도출할 수 있을거라고 생각\n→ answer는 [교집합의 수 + 0의 개수, 교집합의 수]\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\ndef solution(lottos, win_nums):\n    win_count = {\n        6: 1,\n        5: 2,\n        4: 3,\n        3: 4,\n        2: 5,\n        1: 6,\n        0: 6\n    }\n    # 모든 번호가 일치\n    if set(lottos) == set(win_nums):\n        return [1, 1]\n\n    answer = []\n\n    # 0의 갯수 카운트\n    zero = lottos.count(0)\n\n    while 0 in lottos:\n        lottos.remove(0)\n\n    # 구매한 번호와 당첨 번호의 교집합 갯수\n    count = len(set(lottos) &amp;amp; set(win_nums))\n    # 최고 순위\n    answer.append(win_count[count + zero])\n    # 최저 순위\n    answer.append(win_count[count])\n    \n    return answer\n\n\n풀고보니 굳이 while문을 통해 0을 제거하는 작업을 할 필요가 없었습니다.\n\n그리고 다른 사람의 풀이를 찾아봤습니다.\n\n[숏코드]\n\ndef solution(lottos, win_nums):\n    rank = {\n        0: 6,\n        1: 6,\n        2: 5,\n        3: 4,\n        4: 3,\n        5: 2,\n        6: 1\n    }\n    return [rank[len(set(lottos) &amp;amp; set(win_nums)) + lottos.count(0)], rank[len(set(lottos) &amp;amp; set(win_nums))]]\n\n\n[여담]\n\n요즘 알고리즘 문제를 자주 풀어보며 느끼게 된 것이 있습니다.\n\n나는 문제를 풀 때, 매번 사용하는? 나만의 스타일이 없는 것 같다고 느낌을 받았습니다.\n\n어떨 땐 효율을 생각해서 변수 사용을 최소화하고, 어떨 땐 가독성을 위해 변수를 꼬박꼬박 사용했습니다.\n\n실제 협업을 할 때는 상황에 따라 방식이나 스타일이 달라질 필요가 있겠지만 공부할 때는 나만의 스타일을 한 번 고집해봐야겠습니다.\n"
} ,
  
  {
    "title"    : "[백준 2839번] 설탕 배달",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/09/%EB%B0%B1%EC%A4%80-2839%EB%B2%88.html",
    "date"     : "August 9, 2021",
    "excerpt"  : "\n\n백준 “설탕 배달” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n\n상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬...",
  "content"  : "\n\n백준 “설탕 배달” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n\n상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.\n\n상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.\n\n입력\n\n첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)\n\n출력\n\n상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.\n\n예제 입력 1\n\n18\n\n\n예제 출력 1\n\n4\n\n\n예제 입력 2\n\n4\n\n\n예제 출력 2\n\n-1\n\n\n예제 입력 3\n\n6\n\n\n예제 출력 3\n\n2\n\n\n예제 입력 4\n\n9\n\n\n예제 출력 4\n\n3\n\n\n예제 입력 5\n\n11\n\n\n예제 출력 5\n\n3\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  큰 수(5)부터 확인하고, 작은 수(3)를 처리하면 간단하게 해결될 것 같음\n→ DP 문제\n  조건문을 최소화하여 효율성을 높이는 것을 목표 \n→ 테스트 결과 : 64ms\n\n\n[코드]\n\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\n\nresult = 0\nwhile N&amp;gt;=0:\n    # 총 무게 N 나누기 5의 나머지가 0인 경우\n    if N % 5 == 0:\n        # N 나누기 5의 몫을 result에 더하여 출력\n        result += N // 5\n        print(result)\n        break\n    # 3킬로 짜리 1개 추가하는 경우\n    # 총 무게 N에서 -3, 봉지 +1\n    N -= 3\n    result += 1\n\nelse:\n    # 반복문이 종료될 때까지 답이 찾아지지 않으면,\n    # 3과 5로 N을 만들수 없으므로 -1 출력\n    print(-1)\n\n"
} ,
  
  {
    "title"    : "[백준 2775번] 부녀회장이 될테야",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/09/%EB%B0%B1%EC%A4%80-2775%EB%B2%88.html",
    "date"     : "August 9, 2021",
    "excerpt"  : "\n\n백준 “부녀회장이 될테야” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.\n\n이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야...",
  "content"  : "\n\n백준 “부녀회장이 될테야” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.\n\n이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.\n\n아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.\n\n입력\n\n첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다\n\n출력\n\n각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.\n\n제한\n\n\n  1 ≤ k, n ≤ 14\n\n\n예제 입력 1\n\n2\n1\n3\n2\n3\n\n\n예제 출력 1\n\n6\n10\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  데이터가 담겨있는 구조를 생성하는게 좋을 것 같음\n  {층 : [방, 방, 방, …]} 형태의 구조를 만들면 k, n 입력을 인덱스로 활용해서 바로 출력 가능할 것이라고 생각\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport sys\ninput = sys.stdin.readline\n\nT = int(input())\n\nresult = list()\nfor _ in range(T):\n    # 층수 입력 -&amp;gt; 0부터\n    k = int(input())\n    # 호수 입력 -&amp;gt; 1부터\n    n = int(input())\n    # 0층의 데이터를 생성\n    people = {0: [int(i) for i in range(1, n+1)]}\n    # k층은 k-1층의 데이터를 이용하여 층별 초기 데이터 생성\n    for floor in range(1, k+1):\n        people[floor] = people[floor-1][:]\n        for room in range(1, n):\n            # 각각 방의 인원을 계산\n            people[floor][room] += people[floor][room-1]\n    # 입력받은 k층 n호 방의 인원은 마지막 방이기 때문에 인덱스[-1]을 사용\n    # -&amp;gt; 동적으로 바뀌는 n보다는 -1의 고정값이 효율적이지 않을까 생각해서 사용\n    result.append(str(people[k][-1]))\nprint(&#39;\\n&#39;.join(result))\n\n\n[여담]\n\n입주 조건이 참~ 까다로운데 인기가 많은 아파트인듯\n"
} ,
  
  {
    "title"    : "[백준 1011번] Fly me to the Alpha Centauri",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/08/%EB%B0%B1%EC%A4%80-1011%EB%B2%88.html",
    "date"     : "August 8, 2021",
    "excerpt"  : "\n\n백준 “Fly me to the Alpha Centauri” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.\n\n그가 탑승하게 될 우주선은 ...",
  "content"  : "\n\n백준 “Fly me to the Alpha Centauri” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.\n\n그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k-1 , k 혹은 k+1 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. )\n\n\n\n김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 x지점에서 y지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 y지점에 도착해서도 공간 이동장치의 안전성을 위하여 y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.\n\n김우현을 위해 x지점부터 정확히 y지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.\n\n입력\n\n입력의 첫 줄에는 테스트케이스의 개수 T가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다. (0 ≤ x &amp;lt; y &amp;lt; 231)\n\n출력\n\n각 테스트 케이스에 대해 x지점으로부터 y지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.\n\n예제 입력 1\n\n3\n0 3\n1 5\n45 50\n\n\n\n예제 출력 1\n\n3\n3\n4\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  마지막엔 무조건 1로 거리를 움직여야 함\n  움직이는 거리가 긴 횟수의 규칙을 찾아보면 좋을 것 같음\n\n\n[코드]\n\nimport sys\ninput = sys.stdin.readline\n\nT = int(input())\n\n# 테스트 케이스 T만큼 반복\nfor _ in range(T):\n    # 출발점 x, 도착점 y\n    x, y = map(int, input().split())\n    # 이동해야할 거리 계산\n    dis = y - x\n    count = 0\n    # 이동한 거리 -&amp;gt; 최소 1\n    move = 1\n    # 이동한 총 거리\n    total_move = 0\n\n    while total_move &amp;lt; dis:\n        # 반환값이 이동한 횟수이기 때문에 카운트는 +1만\n        count += 1\n        total_move += move\n        # 규칙 : 이동한 횟수가 2의 배수일 때 거리 증가\n        if count % 2 == 0:\n            move += 1\n\n    print(count)\n\n\n[여담]\n\n나의 코드는 실행 시간이 생각보다 길게(1000ms 이상) 나왔습니다.\n\n생각보다 오래 걸려서 다른 사람의 풀이를 한 번 찾아봤습니다.\n\n[다른 사람 코드]\n\nimport sys\nimport math\n\ninput = sys.stdin.readline\n\nT = int(input())\n\nfor i in range(T):\n    x, y = map(int, input().split())\n    dis = y - x\n    # ---------- 이 위쪽까지는 동일했다 ----------\n    k = int(-(-math.sqrt(dis) // 1))\n    if dis &amp;lt;= (k - 1) * k:\n        count = 2 * k - 2\n    else:\n        count = 2 * k - 1\n\n    print(count)\n\n\n이 코드는 실행 시간이 아주x2 짧게(100ms 미만) 나왔습니다.\n\nk를 구하는 식은 아래의 조건에서 발생했습니다.\n\n[이동 횟수의 변화 조건]\n\n\n  거리가 4보다 작은 구간\n  거리가 제곱수인 구간\n  거리가 제곱수 + 제곱근보다 작거나 같은 구간\n  거리가 제곱수 + 제곱근보다 큰 구간\n\n\n대부분 검색을 통해 찾아본 코드는 k를 구하는 식이 이동해야할 거리의 제곱근을 정수화 하는 식이었습니다.\n\nk = int(math.sqrt(이동해야할 거리))\n\n\n하지만 위 코드는 k값을 제곱근에 음수를 곱하고 몫을 구해 정수화 를 진행하여, 검색을 통해 찾아본 코드보다 +1이 되는 상태를 만들었습니다. 그리고 k값을 통해서 if문의 조건식을 1개로 줄였습니다.\n\nk = int(-(-math.sqrt(이동해야할 거리) // 1))\n\n\n대단쓰~\n"
} ,
  
  {
    "title"    : "[백준 2447번] 별 찍기 - 10",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/07/%EB%B0%B1%EC%A4%80-2447%EB%B2%88.html",
    "date"     : "August 7, 2021",
    "excerpt"  : "\n\n백준 “별 찍기 - 10” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, …)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.\n\n크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.\n\n***\n* *\n***\n\n\nN이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운...",
  "content"  : "\n\n백준 “별 찍기 - 10” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제\n\n재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, …)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.\n\n크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.\n\n***\n* *\n***\n\n\nN이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.\n\n입력\n\n첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k &amp;lt; 8이다.\n\n출력\n\n첫째 줄부터 N번째 줄까지 별을 출력한다.\n\n예제 입력 1\n\n27\n\n\n예제 출력 1\n\n***************************\n* ** ** ** ** ** ** ** ** *\n***************************\n***   ******   ******   ***\n* *   * ** *   * ** *   * *\n***   ******   ******   ***\n***************************\n* ** ** ** ** ** ** ** ** *\n***************************\n*********         *********\n* ** ** *         * ** ** *\n*********         *********\n***   ***         ***   ***\n* *   * *         * *   * *\n***   ***         ***   ***\n*********         *********\n* ** ** *         * ** ** *\n*********         *********\n***************************\n* ** ** ** ** ** ** ** ** *\n***************************\n***   ******   ******   ***\n* *   * ** *   * ** *   * *\n***   ******   ******   ***\n***************************\n* ** ** ** ** ** ** ** ** *\n***************************\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  문제의 요구대로 재귀함수를 사용\n  접근 방식은 2가지 방식이 떠올랐습니다.\n    \n      \n        3등분하여 연산\n\n        \n      \n      \n        좌표별 아이템 복사\n\n        \n      \n    \n  \n\n\n3등분하여 연산하는 방식으로 풀어보는 것이 간결할 것이라고 생각이 들어서 진행했습니다.\n\n[코드]\n\nimport sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\n# 재귀함수\ndef draw_star(leng):\n    # 최하단인 경우 &#39;*&#39; 반환\n    if leng == 1:\n        return [&#39;*&#39;]\n\n    # 최하단까지 재귀함수를 사용\n    stars = draw_star(leng // 3)\n    Map = []\n\n    # 최하단부터 반환받은 아이템을 나열하여 전체적인 그림을 맞춤\n    # 윗줄, 반환받은 아이템 나열\n    for s in stars:\n        Map.append(s * 3)\n    # 중간, 반환받은 아이템 사이에 공백을 포함하여 나열\n    for s in stars:\n        Map.append(s + &#39; &#39; * (leng // 3) + s)\n    # 아랫줄, 반환 받은 아이템 나열\n    for s in stars:\n        Map.append(s * 3)\n    return Map\n\nn = int(input())\n# 리스트 타입이라 문자열로 변환\nprint(&#39;\\n&#39;.join(draw_star(n)))\n\n\n[여담]\n\n처음 진행할 때는 데이터 타입을 리스트가 아닌 문자열로 사용해서 \\n 때문에 제대로 출력이 되지 않아 삽질?을 조금 했습니다.\n\n머리를 refresh 할 수 있었던 문제였습니다.\n"
} ,
  
  {
    "title"    : "[Design Pattern] 프록시 패턴 (Proxy)",
    "category" : "",
    "tags"     : " 디자인패턴",
    "url"      : "/2021/08/06/Designe-Pattern-Proxy.html",
    "date"     : "August 6, 2021",
    "excerpt"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행할 수 있다.\n\n  복합적인 오브젝트들의 다수의 복사본이 존재해야만 하는 상황에서 프록시 패턴은 애플리케이션의 메모리 사용량을 줄이기 위해서 플라이웨이트 패턴...",
  "content"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행할 수 있다.\n\n  복합적인 오브젝트들의 다수의 복사본이 존재해야만 하는 상황에서 프록시 패턴은 애플리케이션의 메모리 사용량을 줄이기 위해서 플라이웨이트 패턴 과 결합된 형태로 나올 수도 있다. (GoF 구조에 포함)\n\n  “위키백과 - Proxy”\n\n\n\n  복잡한 시스템을 간단하게 나타낼 때 사용한다고 합니다.\n  실제 오브젝트에 보안을 제공할 수 있다고 합니다.\n  유튜브에서 마우스가 영상에 포커싱 되기 전에는 클립 이미지 를 보여주고, 포커싱 이 되었을 때 클립 영상 을 보여주는 상황에 이용하면 좋을 것 같다고 생각이 들었습니다.\n\n\n예시 코드\n\nclient가 영상에 포커싱을 하기 전에는 클립 이미지 를 보여주고, 포커싱 되었을 때 클립 영상이 재생\n\n(SubInterface의 __ metaclass__ = ABCMeta 설정은 인터페이스의 역할)\n\nimport abc\n\nclass SubInterface:\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def show(self):\n        pass\n\nclass Video(SubInterface):\n    def show(self):\n        return &#39;클립 영상 재생&#39;\n\nclass Proxy(SubInterface):\n    def __init__(self, video):\n        self.video = video\n\n    def show(self, state):\n        if state == &#39;focusing&#39;:\n            return self.video.show()\n        else:\n            return &#39;클립 이미지 상태&#39;\n\nclass Client:\n    def __init__(self, _object):\n        self.state = None\n        self.object = _object\n\n    def move_mouse(self):\n        self.state = &#39;focusing&#39;\n\n    def show(self):\n        return self.object.show(self.state)\n\nif __name__ == &#39;__main__&#39;:\n    origin_video = Video()\n    proxy = Proxy(origin_video)\n    client = Client(proxy)\n    \n    print(f&#39;아무것도 안함 : {client.show()}&#39;)\n    client.move_mouse()\n    print(f&#39;영상에 포커싱함 : {client.show()}&#39;)\n\n\n결과\n\n클립 이미지를 보여주다가 영상에 마우스가 포커싱 될 때, 클립 영상이 재생된 것을 확인할 수 있습니다.\n\n\n"
} ,
  
  {
    "title"    : "[Design Pattern] 어댑터 패턴 (Adapter)",
    "category" : "",
    "tags"     : " 디자인패턴",
    "url"      : "/2021/08/05/Designe-Pattern-Adapter.html",
    "date"     : "August 5, 2021",
    "excerpt"  : "\n\n설명\n\n항상 보던 위키백과를 보겠습니다.\n\n\n  클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해준다. (GoF 구조에 포함)\n\n  “위키백과 - Adapter”\n\n\n\n  가장 설명이 간결한 디자인 패턴 같습니다.\n  기존 구조에 외부 기능을 접목시킬 때, 중간자 역할을 구성하는 방식입니다.\n\n\n예시 코드\n\n위키백과의 예제를 ...",
  "content"  : "\n\n설명\n\n항상 보던 위키백과를 보겠습니다.\n\n\n  클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해준다. (GoF 구조에 포함)\n\n  “위키백과 - Adapter”\n\n\n\n  가장 설명이 간결한 디자인 패턴 같습니다.\n  기존 구조에 외부 기능을 접목시킬 때, 중간자 역할을 구성하는 방식입니다.\n\n\n예시 코드\n\n위키백과의 예제를 가져왔습니다.\n\nclass Target(object):\n    def specific_request(self):\n        return &#39;Hello Adapter Pattern&#39;\n\nclass Adapter(object):\n    def __init__(self, adapter):\n        self.adapter = adapter\n\n    def request(self):\n        return self.adapter.specific_request()\n\nclient = Adapter(Target())\nprint(client.request())\n\n\n결과\n\nTarget 클래스의 specific_request() 함수를 바로 호출할 수 없어서 Adapter 클래스의 request() 함수를 통해 Target 클래스의 specific_request() 함수를 호출했습니다.\n\n\n"
} ,
  
  {
    "title"    : "[Design Pattern] 커맨드 패턴 (Command)",
    "category" : "",
    "tags"     : " 디자인패턴",
    "url"      : "/2021/08/04/Designe-Pattern-Command.html",
    "date"     : "August 4, 2021",
    "excerpt"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 메서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다. (GoF 행위에 포함)\n\n  “위키백과 - Command”\n\n\n\n  Strategy Pattern과 비슷합니다.\n  Strategy는 같은 일을 알고리즘이나 방식을 바꿔서 수행, Command는 하는 일 자...",
  "content"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 메서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다. (GoF 행위에 포함)\n\n  “위키백과 - Command”\n\n\n\n  Strategy Pattern과 비슷합니다.\n  Strategy는 같은 일을 알고리즘이나 방식을 바꿔서 수행, Command는 하는 일 자체가 다릅니다.\n  각각 명령을 객체의 형태로 작성하는 느낌이라 명령의 조합이 필요한 게임 캐릭터의 컨트롤 같은 상황에서 사용하면 좋을 것 같다고 생각이 들었습니다.\n\n\n예시 코드\n\njanos라는 Warrior 클래스의 객체를 생성하고, 창과 해머 무기에 따라서 다른 공격 모션을 수행\n\nimport abc\n\nclass Warrior:\n    def __init__(self):\n        self.swapCommand = []\n        self.attackCommand = []\n\n    def setCommand(self, swapCommand, attackCommand):\n        self.swapCommand.append(swapCommand)\n        self.attackCommand.append(attackCommand)\n\n    def swapButton(self, slot):\n        self.swapCommand[slot].execute()\n    \n    def attackButton(self, slot):\n        self.attackCommand[slot].execute()\n\nclass Spear:\n    def swap(self):\n        print(&#39;해머에서 창으로 변경&#39;)\n\n    def attack(self):\n        print(&#39;찌르기 공격&#39;)\n\nclass Hammer:\n    def swap(self):\n        print(&#39;창에서 해머로 변경&#39;)\n\n    def attack(self):\n        print(&#39;휘두르기 공격&#39;)\n\nclass Command:\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def execute(self):\n        pass\n\nclass SpearSwapCommand(Command):\n    def __init__(self, spear_obj):\n        self.spear = spear_obj\n\n    def execute(self):\n        self.spear.swap()\n\nclass SpearAttackCommand(Command):\n    def __init__(self, spear_obj):\n        self.spear = spear_obj\n\n    def execute(self):\n        self.spear.attack()\n\nclass HammerSwapCommand(Command):\n    def __init__(self, hammer_obj):\n        self.hammer = hammer_obj\n\n    def execute(self):\n        self.hammer.swap()\n\nclass HammerAttackCommand(Command):\n    def __init__(self, hammer_obj):\n        self.hammer = hammer_obj\n\n    def execute(self):\n        self.hammer.attack()\n\nif __name__ == &#39;__main__&#39;:\n    janos = Warrior()\n\n    spear_obj = Spear()\n    hammer_obj = Hammer()\n\n    spearSwapButton = SpearSwapCommand(spear_obj)\n    spearAttackButton = SpearAttackCommand(spear_obj)\n    hammerSwapButton = HammerSwapCommand(hammer_obj)\n    hammerAttackButton = HammerAttackCommand(hammer_obj)\n\n    janos.setCommand(spearSwapButton, spearAttackButton)\n    janos.setCommand(hammerSwapButton, hammerAttackButton)\n\n    janos.swapButton(0)\n    janos.attackButton(0)\n    janos.swapButton(1)\n    janos.attackButton(1)\n\n\n결과\n\n착용한 무기가 창인 경우는 찌르기, 해머인 경우는 휘두르기 공격이 수행되고, 서로 다른 무기로 스왑이 진행됩니다.\n\n\n"
} ,
  
  {
    "title"    : "스코프 (Scope)",
    "category" : "",
    "tags"     : " 기본기",
    "url"      : "/2021/08/03/%EC%8A%A4%EC%BD%94%ED%94%84-Scope.html",
    "date"     : "August 3, 2021",
    "excerpt"  : "\n\n먼저 위키백과의 내용을 보면 아래와 같습니다.\n\n\n  컴퓨터 프로그래밍에서 변수 영역은 변수가 유효성을 갖는 영역을 가리킨다. 프로그램은 영역을 벗어난 변수를 가리킬 수 없다.\n\n  변수의 영역을 지정하는 규칙은 크게 정적 영역 규칙과 동적 영역 규칙으로 나뉜다. 정적 영역 규칙을 따르는 언어에서는 변수의 유효 영역이 컴파일 타임에 결정되며, 동적 영역 규칙은 실행 시간에 결정된다. 대부분의 현대 언어는 정적 영역 규칙을 따른다.\n\n ...",
  "content"  : "\n\n먼저 위키백과의 내용을 보면 아래와 같습니다.\n\n\n  컴퓨터 프로그래밍에서 변수 영역은 변수가 유효성을 갖는 영역을 가리킨다. 프로그램은 영역을 벗어난 변수를 가리킬 수 없다.\n\n  변수의 영역을 지정하는 규칙은 크게 정적 영역 규칙과 동적 영역 규칙으로 나뉜다. 정적 영역 규칙을 따르는 언어에서는 변수의 유효 영역이 컴파일 타임에 결정되며, 동적 영역 규칙은 실행 시간에 결정된다. 대부분의 현대 언어는 정적 영역 규칙을 따른다.\n\n  “위키백과 - 변수 영역”\n\n\n\n  1. 전역\n  2. 모듈 영역\n  3. 파일 영역\n  4. 함수 영역\n  5. 블록 영역\n  6. 표현식 영역\n\n\n1. 전역\n\n소스 코드 상의 모든 곳에서 사용할 수 있는 전역 변수이다. 대부분의 언어에서 나쁜 습관으로 취급되는 전역 변수지만, 함수명이나 클래스명은 대부분 전역에서 접근할 수 있습니다.\n\nnamespace를 사용하면 전역 영역에서 변수나 함수명이 충돌하는 것을 막을 수 있습니다.\n\n\n  Python에서는 함수 안에서 상위 범위(Scope)의 변수를 사용하기 위해서 global , nonlocal 키워드를 사용합니다.\n  global은 전역\n  nonlocal은 상위 함수\n\n\n[global - 예시 코드]\n\nglobal_var = &#39;global&#39;\n\ndef test_func():\n    global global_var\n    global_var += &#39; local&#39;\n\nglobal_var += &#39; end&#39;\ntest_func()\nprint(global_var)\n---------------------------------------------------\n&#39;global end local&#39;\n\n\n[nonlocal - 예시 코드]\n\ndef parents_func():\n    local_var = &#39;local&#39;\n\n    def child_func():\n        nonlocal local_var\n        local_var += &#39; child&#39;\n\n    child_func()\n    print(local_var)\nparents_func()\n---------------------------------------------------\n&#39;local child&#39;\n\n\n2. 모듈 영역\n\nPython과 같이 모듈을 지원하는 프로그래밍 언어에서는 모듈 단위 변수를 선언할 수 있습니다. 모듈 밖에서는 변수를 볼 수 없습니다.\n\n3. 파일 영역\n\nC와 C++ 및 그 유사 언어에서만 지원하는 개념입니다. 파일 영역은 보다 원시적인 형태의 모듈 영역이라고 할 수 있습니다.\n\n4. 함수 영역\n\n거의 모든의 프로그래밍 언어는 함수 내에서만 유효한 지역 변수를 제공합니다. 함수안에 지역 변수는 함수가 반환되면 더 이상 사용할 수 없습니다.\n\n[예시 코드]\n\ndef parents_func():\n    local_var = &#39;local&#39;\n\ndef child_func():\n    print(local_var)\n\nchild_func()\n---------------------------------------------------\nNameError: name &#39;local_var&#39; is not defined\n\n\nparents_func() 함수의 영역에 있는 변수 local_var 을 child_func() 함수 영역에서 접근하면 선언되지 않았다는 에러가 발생합니다.\n\n5. 블록 영역\n\n코드 블록(if, for, try, catch 등) 영역에서만 유효한 지역 변수입니다.\n\n[예시 코드]\n\nfor (let i=0; i&amp;lt;10; i++){\n    // somthing code\n}\n\n\n위 코드에서 i 는 for 반복문 안에서만 접근이 가능합니다.\n\n6. 표현식 영역\n\n특정 표현식 안에서만 유효한 지역 변수입니다.\n대부분의 함수형 프로그래밍 언어는 let 키워드를 지원합니다.\n간단하게 Javascript의 예시를 보면 아래와 같습니다.\n\n[예시 코드]\n\ntest = lambda x : x + 1\nprint(test(1))\nprint(x)\n---------------------------------------------------\n2\nNameError: name &#39;x&#39; is not defined\n\n\n변수 x는 표현식 안에서만 접근 가능하기 때문에 에러가 발생합니다.\n\n\n  📌 Python은 변수를 찾는 스코프에 LEGB 규칙을 따른다고 한다.\nLocal -&amp;gt; Enclosing -&amp;gt; Global -&amp;gt; Built-in\n\n"
} ,
  
  {
    "title"    : "[카카오 코딩 테스트] 카드 짝 맞추기",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/08/02/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%B9%B4%EB%93%9C-%EC%A7%9D-%EB%A7%9E%EC%B6%94%EA%B8%B0.html",
    "date"     : "August 2, 2021",
    "excerpt"  : "\n\n2021 KAKAO BLIND RECRUITMENT “카드 짝 맞추기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n게임 개발자인 베로니는 개발 연습을 위해 다음과 같은 간단한 카드 짝맞추기 보드 게임을 개발해 보려고 합니다.게임이 시작되면 화면에는 카드 16장이 뒷면을 위로하여 4 x 4 크기의 격자 형태로 표시되어 있습니다. 각 카드의 앞면에는 카카오프렌즈 캐릭터 그림이 그려져 있으며...",
  "content"  : "\n\n2021 KAKAO BLIND RECRUITMENT “카드 짝 맞추기” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n게임 개발자인 베로니는 개발 연습을 위해 다음과 같은 간단한 카드 짝맞추기 보드 게임을 개발해 보려고 합니다.게임이 시작되면 화면에는 카드 16장이 뒷면을 위로하여 4 x 4 크기의 격자 형태로 표시되어 있습니다. 각 카드의 앞면에는 카카오프렌즈 캐릭터 그림이 그려져 있으며, 8가지의 캐릭터 그림이 그려진 카드가 각기 2장씩 화면에 무작위로 배치되어 있습니다.유저가 카드를 2장 선택하여 앞면으로 뒤집었을 때 같은 그림이 그려진 카드면 해당 카드는 게임 화면에서 사라지며, 같은 그림이 아니라면 원래 상태로 뒷면이 보이도록 뒤집힙니다. 이와 같은 방법으로 모든 카드를 화면에서 사라지게 하면 게임이 종료됩니다.\n\n게임에서 카드를 선택하는 방법은 다음과 같습니다.\n\n\n  카드는 커서를 이용해서 선택할 수 있습니다.\n    \n      커서는 4 x 4 화면에서 유저가 선택한 현재 위치를 표시하는 “굵고 빨간 테두리 상자”를 의미합니다.\n    \n  \n  커서는 [Ctrl] 키와 방향키에 의해 이동되며 키 조작법은 다음과 같습니다.\n    \n      방향키 ←, ↑, ↓, → 중 하나를 누르면, 커서가 누른 키 방향으로 1칸 이동합니다.\n      [Ctrl] 키를 누른 상태에서 방향키 ←, ↑, ↓, → 중 하나를 누르면, 누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다.\n        \n          만약, 해당 방향에 카드가 하나도 없다면 그 방향의 가장 마지막 칸으로 이동합니다.\n        \n      \n      만약, 누른 키 방향으로 이동 가능한 카드 또는 빈 공간이 없어 이동할 수 없다면 커서는 움직이지 않습니다.\n    \n  \n  커서가 위치한 카드를 뒤집기 위해서는 [Enter] 키를 입력합니다.\n    \n      [Enter] 키를 입력해서 카드를 뒤집었을 때\n        \n          앞면이 보이는 카드가 1장 뿐이라면 그림을 맞출 수 없으므로 두번째 카드를 뒤집을 때 까지 앞면을 유지합니다.\n          앞면이 보이는 카드가 2장이 된 경우, 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며, 그림이 다르다면 두 카드 모두 뒷면이 보이도록 다시 뒤집힙니다.\n        \n      \n    \n  \n\n\n“베로니”는 게임 진행 중 카드의 짝을 맞춰 몇 장 제거된 상태에서 카드 앞면의 그림을 알고 있다면, 남은 카드를 모두 제거하는데 필요한 키 조작 횟수의 최솟값을 구해 보려고 합니다. 키 조작 횟수는 방향키와 [Enter] 키를 누르는 동작을 각각 조작 횟수 1로 계산하며, [Ctrl] 키와 방향키를 함께 누르는 동작 또한 조작 횟수 1로 계산합니다.\n\n다음은 카드가 몇 장 제거된 상태의 게임 화면에서 커서를 이동하는 예시입니다.아래 그림에서 빈 칸은 이미 카드가 제거되어 없어진 칸을 의미하며, 그림이 그려진 칸은 카드 앞 면에 그려진 그림을 나타냅니다.\n\n\n\n예시에서 커서는 두번째 행, 첫번째 열 위치에서 시작하였습니다.\n\n\n\n[Enter] 입력, ↓ 이동, [Ctrl]+→ 이동, [Enter] 입력 = 키 조작 4회\n\n\n\n[Ctrl]+↑ 이동, [Enter] 입력, [Ctrl]+← 이동, [Ctrl]+↓ 이동, [Enter] 입력 = 키 조작 5회\n\n\n\n[Ctrl]+→ 이동, [Enter] 입력, [Ctrl]+↑ 이동, [Ctrl]+← 이동, [Enter] 입력 = 키 조작 5회\n\n위와 같은 방법으로 커서를 이동하여 카드를 선택하고 그림을 맞추어 카드를 모두 제거하기 위해서는 총 14번(방향 이동 8번, [Enter] 키 입력 6번)의 키 조작 횟수가 필요합니다.\n\n\n\n[문제]\n\n현재 카드가 놓인 상태를 나타내는 2차원 배열 board와 커서의 처음 위치 r, c가 매개변수로 주어질 때, 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.\n\n[제한사항]\n\n\n  board는 4 x 4 크기의 2차원 배열입니다.\n  board 배열의 각 원소는 0 이상 6 이하인 자연수입니다.\n    \n      0은 카드가 제거된 빈 칸을 나타냅니다.\n      1 부터 6까지의 자연수는 2개씩 들어있으며 같은 숫자는 같은 그림의 카드를 의미합니다.\n      뒤집을 카드가 없는 경우(board의 모든 원소가 0인 경우)는 입력으로 주어지지 않습니다.\n    \n  \n  r은 커서의 최초 세로(행) 위치를 의미합니다.\n  c는 커서의 최초 가로(열) 위치를 의미합니다.\n  r과 c는 0 이상 3 이하인 정수입니다.\n  게임 화면의 좌측 상단이 (0, 0), 우측 하단이 (3, 3) 입니다.\n\n\n\n\n[입출력 예]\n\n\n  \n    \n      board\n      r\n      c\n      result\n    \n  \n  \n    \n      [[1,0,0,3],[2,0,0,0],[0,0,0,2],[3,0,1,0]]\n      1\n      0\n      14\n    \n    \n      [[3,0,0,2],[0,0,1,0],[0,1,0,0],[2,0,0,3]]\n      0\n      1\n      16\n    \n  \n\n\n입출력 예에 대한 설명\n\n\n\n입출력 예 #1문제의 예시와 같습니다.\n\n입출력 예 #2입력으로 주어진 게임 화면은 아래 그림과 같습니다.\n\n\n\n위 게임 화면에서 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값은 16번 입니다.\n\n\n\nSolution\n\n[문제 이해]\n\n문제의 의도를 제대로 이해하지 못해서 구현 문제에도 불구하고 검색을 하게 되었습니다.\n\n우선 작성한 코드를 보겠습니다.\n\n[실패한 코드]\n\nimport numpy as np\nfrom queue import Queue\nfrom collections import defaultdict\n\ndef solution(board, r, c):\n    deck = defaultdict(list)\n\n    # 카드별 위치 덱 생성\n    for y, b in enumerate(board):\n        arr = np.array(b)\n        for i in range(1, 7):\n            x = list(np.where(arr == i)[0])\n            if x != []:\n                deck[i].append([y, x[0]])\n\n    answer = 0\n    now_loc = [r, c]\n    # deck 다 찾으면 끝나게 루프 구성\n    while deck:\n        min_dis = float(&#39;inf&#39;)\n        # 가까운 카드 위치 찾기\n        for i in deck:\n            for idx, j in enumerate(deck[i]):\n                new_dis = 0\n                y, x = j\n                if now_loc[0] != j[0]: new_dis += 1\n                if now_loc[1] != j[1]: new_dis += 1\n                if new_dis &amp;lt; min_dis:\n                    min_dis = new_dis\n                    min_pos = [y, x, i, idx]\n\n        # 현재 위치 및 카운트 갱신\n        now_loc = min_pos[:2]\n        answer += min_dis\n        answer += 1\n\n        # 카드 짝 위치 찾기\n        couple_loc = deck[min_pos[2]][int(not min_pos[3])]\n\n        # 현재 위치 및 카운트 갱신\n        if now_loc[0] != couple_loc[0]:\n            now_loc[0] = couple_loc[0]\n            answer += 1\n        if now_loc[1] != couple_loc[1]:\n            now_loc[1] = couple_loc[1]\n            answer += 1\n        answer += 1\n\n        # 짝 찾은 카드 제거 -&amp;gt; 덱을 비우면 루프 탈출\n        del deck[min_pos[2]]\n        \n    return answer\n\n\n처음 테스트 케이스 2개는 통과했지만 채점할 때는 수많은 실패를 보여준 코드입니다.\n\n내가 이해한 의도는 가장 짧은 이동 경로를 통해 카드 뒤집기를 끝내야하는 것으로 이해했지만, 검색을 해보니 사실 문제의 의도는 모든 경우의 수를 빠르게 확인해 봐야 하는 것이라고 했습니다.\n\n문제 의도 파악 실패와 공개된 테스트 케이스 예시에만 포커싱을 해서 코딩을 한 결과 같습니다.\n\n그래서 검색을 통해 구성에 필요한 요소들을 인지했습니다.\n\n\n  Queue → deque 사용\n  전체 이동경로 탐색\n\n\n그리고 다시 코드를 작성했습니다.\n\n[성공한 코드]\n\nfrom collections import deque as dq\n\ndef solution(board, r, c):\n    answer = 10**6\n    SIZE = 4\n    DELTAS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n    \n    # 입력 좌표가 가장자리인지 확인\n    def _is_in_range(r, c):\n        return 0 &amp;lt;= r &amp;lt; SIZE and 0 &amp;lt;= c &amp;lt; SIZE\n\n    # 짝 맞추기 후 board 비우기\n    def _is_empty(r, c, bd):\n        return bd[r][c] == 0\n\n    # 🔽, ◀️, 🔼, ▶️ 방향 탐색\n    def _yield_moves(d, r, c, bd):\n        for dr, dc in DELTAS:\n            nr = r + dr\n            nc = c + dc\n            if not _is_in_range(nr, nc):\n                continue\n            # 제너레이터를 반환하여 효율성 향상 -&amp;gt; yield\n            # 탐색마다 현재 길이를 추가해서 반환 -&amp;gt; d + 1\n            yield(d+1, nr, nc)\n            while _is_empty(nr, nc, bd) and _is_in_range(nr+dr, nc+dc):\n                nr = nr + dr\n                nc = nc + dc\n            yield(d+1, nr, nc)\n\n    # 기준 좌표(r, c)에서 현재 좌표(nr, nc)로 이동하기 위한 함수\n    def go(r, c, nr, nc, bd):\n        q = dq()\n        q.append((0, r, c))\n        visited = set()\n        \n        while q:\n            d, r, c = q.popleft()\n            # 기준 좌표와 현재 좌표가 같으면 현재 길이 반환\n            if (r, c) == (nr, nc):\n                return d\n            # 기준 좌표가 방문한적이 있는 좌표인지 확인\n            if (d, r, c) not in visited:\n                visited.add((d, r, c))\n                # 움직일 방향을 탐색하여 다음 이동 경로를 큐에 담음\n                for next_cursor in _yield_moves(d, r, c, bd):\n                    q.append(next_cursor)\n        return 0\n\n    deck = []\n    # 전체 board에서 짝을 맞출 카드가 있는 좌표와 카드 종류를 탐색 -&amp;gt; (종류, y, x)\n    for i, arr in enumerate(board):\n        for j, val in enumerate(arr):\n            if val != 0:\n                deck.append((val, i, j))\n\n    # 맞춘 짝을 체크하기 위한 리스트 생성 -&amp;gt; deck이 짝이 있는 카드 뭉치\n    l = len(deck)\n    used = [0] * l\n\n    # chosen -&amp;gt; 짝을 맞추기 위해 선택한 카드\n    def check(chosen, x, y, board, moves):\n        nonlocal answer, used, l\n        if len(chosen) == l:\n            answer = min(answer, moves+l)\n            return\n        for i in range(l):\n            if not used[i]:\n                if len(chosen) % 2 ==0 or (chosen and chosen[-1][0] == deck[i][0]):\n                    chosen.append(deck[i])\n                    used[i] = 1\n                    # deck에 담겨있는 목표 좌표 얻기\n                    nowX, nowY = deck[i][1], deck[i][2]\n                    # deck에서 얻은 목표 좌표로 이동\n                    n = go(x, y, nowX, nowY, board)\n                    # 이동한 위치의 카드 추출\n                    card = board[nowX][nowY]\n                    board[nowX][nowY] = 0\n\n                    check(chosen, nowX, nowY, board, moves+n)\n                    \n                    # 추출한 카드 재자리\n                    board[nowX][nowY] = card\n                    used[i] = 0\n                    chosen.pop()\n        return\n        \n    check([], r, c, board, 0)\n    return answer\n\n\n[여담]\n\n이번 문제는 이전 문제들보다 의도치 않게 구글의 도움을 많이 받아서 풀게 됐습니다.\n\n아직 부족함을 많이 느끼게 해준 문제였습니다.\n"
} ,
  
  {
    "title"    : "[Design Pattern] 모나드 패턴 (Monad)",
    "category" : "",
    "tags"     : " 디자인패턴",
    "url"      : "/2021/08/01/%EB%AA%A8%EB%82%98%EB%93%9C-Monad.html",
    "date"     : "August 1, 2021",
    "excerpt"  : "\n\n모나드라는 개념을 찾아보며 이해한 부분만 요약하여 정리한 글이라 내용이 다소 생략되어있습니다.\n\n설명\n\n\n  하스켈 등 함수형 프로그래밍 언어에서 입출력 및 데이터 구조를 다룰 때 쓰인다.\n\n  “위키백과 - Monad - version of Korean”\n\n\n뭔가 부족해서, 영어 버전으로 찾아봤습니다.\n\n\n  함수형 프로그래밍에서 모나드는 일반적으로 프로그램을 구조화할 수 있는 추상적 개념이다. 모나드는 두 가지 절차를 따라서 특정한...",
  "content"  : "\n\n모나드라는 개념을 찾아보며 이해한 부분만 요약하여 정리한 글이라 내용이 다소 생략되어있습니다.\n\n설명\n\n\n  하스켈 등 함수형 프로그래밍 언어에서 입출력 및 데이터 구조를 다룰 때 쓰인다.\n\n  “위키백과 - Monad - version of Korean”\n\n\n뭔가 부족해서, 영어 버전으로 찾아봤습니다.\n\n\n  함수형 프로그래밍에서 모나드는 일반적으로 프로그램을 구조화할 수 있는 추상적 개념이다. 모나드는 두 가지 절차를 따라서 특정한 계산 형태를 나타내는 자체 데이터 type을 제공하여 달성한다.\n\n  \n    모나드 내에서 기본 유형의 값을 래핑하는 것 (모나드 값 생성)\n    모나딕 값을 출력하는 함수를 구성하는 것 (모나딕 함수라고 함)\n  \n\n  이를 통해 모나드는 광범위한 문제를 단순화할 수 있다.\n\n  “위키백과 - Monad - version of English”\n\n\n\n  모나드 패턴을 사용하기 위한 절차를 따르면 순수 함수형 프로그래밍의 이점을 많이 얻을 수 있다고 합니다.\n  모나드의 구조가 데코레이터 패턴과 유사하다고 생각이 들었습니다.\n\n\n예시 코드 1\n\n아래의 코드는 입력값 x에 1,2,3을 더한 값을 반환하는 코드입니다.\n\ndef f1(x): return x + 1\ndef f2(x): return x + 2\ndef f3(x): return x + 3\n\n\n위의 코드를 이용해 x, x+1, x+1+2, x+1+2+3의 값을 구하는 코드를 작성해보면 아래와 같이 할 수 있습니다.\n\n_list = [1]    # x가 1인 경우로 가정\n\ntemp = f1(_list[0])\n_list.append(temp)\n\ntemp = f2(temp)\n_list.append(temp)\n\ntemp = f3(temp)\n_list.append(temp)\n\nprint((temp, _list))\n---------------------------------------------------\n(7, [1, 2, 4, 7])\n\n\n하지만 위 방식의 단점은 새로운 함수 f4, f5가 추가될 때 마다 리스트에 값을 수동으로 추가해야 하는 문제가 있습니다.\n\n여기서 모나드 패턴을 사용해보면\n\ndef unit(x):\n    return (x, [x])\n\ndef bind(_list, f):\n    res = f(_list[0])\n    return (res, _list[1] + [res])\n\n# x가 1인 경우로 가정\nresult = bind(bind(bind(unit(1), f1), f2), f3)\nprint(result)\n---------------------------------------------------\n(7, [1, 2, 4, 7])\n\n\n재귀 함수의 느낌과 비슷했습니다.\n\n예시 코드 2\n\n이번엔 객체지향의 특징을 살려서 접근해봤습니다.\n\nclass Employee:\n    def get_boss(self):\n        # Return the employess&#39;s boss\n\n    def get_wage(self):\n        # Compute the wage\n\n# janos라는 직원 객체 생성\njanos = Employee()\n# janos라는 직원의 보스를 얻고, 보스의 임금을 얻기\njanos.get_boss().get_wage()\n\n\n위의 경우에 get_boss()의 반환값이 None인 경우 get_wage()는 Error가 발생합니다.\n\n이런 Error는 아래와 같은 방법으로 방지할 수 있습니다.\n\nresult = None\nif not janos:\n    boss = janos.get_boss()\n    if not boss:\n        wage = boss.get_wage()\n        if not wage:\n            result = wage\n\nprint(result)\n\n\n하지만 위의 코드는 파이썬 철학 Beautiful is better than ugly (아름다운 것이 추한 것보다 낫다) 를 지키지 못한 추한 코드라고 할 수 있습니다.\n\n이 코드를 아름답게 만들기 위해 다시 한 번 모나드 패턴을 사용하면 아래와 같은 호출 형태로 result를 구할 수 있습니다.\n\ndef unit(emp):\n    return emp\n\ndef bind(emp, f):\n    return None if not emp else f(emp)\n\njanos = Employee()\nresult = bind(bind(unit(john), Employee.get_boss), Employee.get_wage)\n\n\n위의 코드를 아래의 함수를 추가해서 한 번 더 아름답게 만들 수 있습니다.\n\ndef pipeline(emp, *fs):\n    for f in fs:\n        emp = bind(emp, f)\n    return emp\n\n\n전체적인 코드를 보면\n\ndef f1(x): return x + 1\ndef f2(x): return x + 2\ndef f3(x): return x + 3\n\ndef unit(emp):\n    return emp\n\ndef bind(emp, f):\n    return None if not emp else f(emp)\n\ndef pipeline(emp, *fs):\n    for f in fs:\n        emp = bind(emp, f)\n    return emp\n\njanos = Employee()\nresult = pipeline(unit(x), f1, f2, f3)\n\n\npipeline 함수를 추가하면서 result를 구하는 bind(bind(... 부분을 단순한 형태로 대체할 수 있습니다.\n\npipeline 함수의 형태를 사용하면 이후에 추가될 수 있는 f4, f5, f6와 같은 추가 함수도 쉽게 활용할 수 있습니다.\n\nresult = pipeline(unit(x), f1, f2, f3, f4, f5, f6)\n\n\n결론\n\n모나드는 함수 구성을 위한 간단하고 강력한 디자인 패턴이다.\n\n이해에 큰 도움이 되었던 페이지 링크를 첨부한다.\n\nReference - https://nikgrozev.com/2013/12/10/monads-in-15-minutes/\n"
} ,
  
  {
    "title"    : "커링 (Currying)",
    "category" : "",
    "tags"     : " 기본기",
    "url"      : "/2021/07/31/%EC%BB%A4%EB%A7%81-Currying.html",
    "date"     : "July 31, 2021",
    "excerpt"  : "\n\n개념\n\n\n  커링(currying)이란 다중 인수를 갖는 함수를 단일 인수를 갖는 함수들의 함수열로 바꾸는 것을 말한다.\n\n  “위키백과 - Currying”\n\n\n예시 코드 1\n\n# 다중 인수 함수\ndef function(num1, num2):\n    return num1 + num2\n\n# function()를 아래의 커링 함수 형태로 대체할 수 있다.\n\n# 커링 형태로 단일 인자를 받는 함수열\ndef curry(num1):\n    d...",
  "content"  : "\n\n개념\n\n\n  커링(currying)이란 다중 인수를 갖는 함수를 단일 인수를 갖는 함수들의 함수열로 바꾸는 것을 말한다.\n\n  “위키백과 - Currying”\n\n\n예시 코드 1\n\n# 다중 인수 함수\ndef function(num1, num2):\n    return num1 + num2\n\n# function()를 아래의 커링 함수 형태로 대체할 수 있다.\n\n# 커링 형태로 단일 인자를 받는 함수열\ndef curry(num1):\n    def function(num2):\n        return num1 + num2\n    return function\n\n\n\n  커링 함수를 사용하면 재사용성이 향상됩니다.\n→ 인자중 변하지 않는 고정값을 두고 자주 변하는 값만 새로 받아가며 활용할 수 있습니다.\n  가독성을 높여줍니다.\n  Python에서 커링을 활용한 아주 좋은 데코레이터 라는 패턴이 있습니다.\n\n\n예시 코드 2 - 데코레이터\n\n함수의 반환된 결과와 경과된 시간이 출력되는 timer라는 이름의 데코레이터 패턴의 함수입니다.\n\nfrom time import time\n# 데코레이터 기능 사용시 signature와 docstring을 보존하기 위해서 사용하는 라이브러리\nfrom functools import wraps\n\n# 데코레이터\ndef timer(func):\n    @wraps(func)\n    # *args는 일반적인 형태의 인자가 입력 되었을 때, 값이 존재\n    # **kwargs는 {key : value} 형태의 인자가 입력 되었을 때, 값이 존재\n    # *args와 **kwargs는 func 함수로 입력된 인자를 전달하기 위해서 사용\n    def wrapper(*args, **kwargs):\n        start = time()\n        result = func(*args, **kwargs)\n        end = time()\n        print(f&#39;실행 결과 : {result} / 경과 시간 : {end - start}&#39;)\n        return result\n    return wrapper\n\n# add 함수 위에 @timer를 작성하여 데코레이터를 설정\n@timer\ndef add(num1, num2):\n    return num1 + num2\n\n@timer\ndef multiple(num1, num2):\n    return num1 * num2\n\nadd(1, 2)\nmultiple(1, 2)\n\n\n결과\n\nadd와 multiple 함수의 실행 결과와 경과 시간이 같이 출력되는 것을 확인할 수 있습니다.\n\n\n"
} ,
  
  {
    "title"    : "[Design Pattern] 상태 패턴 (State)",
    "category" : "",
    "tags"     : " 디자인패턴",
    "url"      : "/2021/07/27/Designe-Pattern-State.html",
    "date"     : "July 27, 2021",
    "excerpt"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  객체 지향 방식으로 state 기계를 구현하는 행위 소프트웨어 디자인 패턴이다. State Pattern을 이용하면 state pattern 인터페이스의 파생 클래스로서 각각의 state를 구현함으로써, 또 패턴의 슈퍼클래스에 의해 정의되는 메소드를 호출하여 상태 변화를 구현함으로써 상태 기계를 구현한다.\n\n  패턴의 인터페이스에 정의된 메소드들의 호출을 통해 현재의 전략을 전환할...",
  "content"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  객체 지향 방식으로 state 기계를 구현하는 행위 소프트웨어 디자인 패턴이다. State Pattern을 이용하면 state pattern 인터페이스의 파생 클래스로서 각각의 state를 구현함으로써, 또 패턴의 슈퍼클래스에 의해 정의되는 메소드를 호출하여 상태 변화를 구현함으로써 상태 기계를 구현한다.\n\n  패턴의 인터페이스에 정의된 메소드들의 호출을 통해 현재의 전략을 전환할 수 있는 Strategy Pattern으로 해석할 수 있다. (GoF 행위에 포함)\n\n  “위키백과 - State”\n\n\n\n  어떤 행위를 수행할 때, state에 따라 수행되는 행위가 달라집니다.\n  Strategy Pattern과 비슷합니다.\n  State는 다크 모드 / 라이트 모드 같은 state에 따른 토글에 이용하면 좋을 것 같다고 생각이 들었습니다.\n\n\n예시 코드\n\n라이트, 다크 모드를 각각 클래스로 생성한 뒤에 모드를 관리하는 State 클래스를 사용하여 Window 클래스에서 현재 모드를 확인하고 변경하는 동작을 수행\n\nclass State:\n    def show_mode(self):\n        print(f&#39;현재 상태는 {self.mode} 모드 입니다.&#39;)\n\nclass LightState(State):\n    def __init__(self, window):\n        self.window = window\n        self.mode = &#39;LIGHT&#39;\n\n    def toggle_DL(self):\n        print(&#39;Swiching to Dark Mode&#39;)\n        self.window.state = self.window.darkstate\n\nclass DarkState(State):\n    def __init__(self, window):\n        self.window = window\n        self.mode = &#39;DARK&#39;\n\n    def toggle_DL(self):\n        print(&#39;Swiching to Light Mode&#39;)\n        self.window.state = self.window.lightstate\n\nclass Window:\n    def __init__(self):\n        self.lightstate = LightState(self)\n        self.darkstate = DarkState(self)\n        self.state = self.lightstate\n\n    def toggle_DL(self):\n        self.state.toggle_DL()\n\n    def show_mode(self):\n        self.state.show_mode()\n\nif __name__ == &#39;__main__&#39;:\n    window = Window()\n    actions = [window.show_mode] + [window.toggle_DL] + [window.show_mode]\n    actions *= 2\n\n    for action in actions:\n        action()\n        print(&#39;-&#39;*20)\n\n\n실행 결과\n\n테스트는 아래의 절차를 2번 반복 진행했습니다.\n\n\n  현재 모드 확인\n  상태 변환\n  다시 현재 모드 확인\n\n\n위의 절차를 진행했을 때, 모드의 상태입니다.\n\n\n  라이트 모드\n  다크 모드\n  다크 모드\n  라이트 모드\n\n\n\n"
} ,
  
  {
    "title"    : "[카카오 코딩 테스트] 광고 삽입",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/07/26/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B4%91%EA%B3%A0-%EC%82%BD%EC%9E%85.html",
    "date"     : "July 26, 2021",
    "excerpt"  : "\n\n2021 KAKAO BLIND RECRUITMENT “광고 삽입” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n카카오TV에서 유명한 크리에이터로 활동 중인 죠르디는 환경 단체로부터 자신의 가장 인기있는 동영상에 지구온난화의 심각성을 알리기 위한 공익광고를 넣어 달라는 요청을 받았습니다. 평소에 환경 문제에 관심을 가지고 있던 “죠르디”는 요청을 받아들였고 광고효과를 높이기 위해 시청자들이...",
  "content"  : "\n\n2021 KAKAO BLIND RECRUITMENT “광고 삽입” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n카카오TV에서 유명한 크리에이터로 활동 중인 죠르디는 환경 단체로부터 자신의 가장 인기있는 동영상에 지구온난화의 심각성을 알리기 위한 공익광고를 넣어 달라는 요청을 받았습니다. 평소에 환경 문제에 관심을 가지고 있던 “죠르디”는 요청을 받아들였고 광고효과를 높이기 위해 시청자들이 가장 많이 보는 구간에 공익광고를 넣으려고 합니다. “죠르디”는 시청자들이 해당 동영상의 어떤 구간을 재생했는 지 알 수 있는 재생구간 기록을 구했고, 해당 기록을 바탕으로 공익광고가 삽입될 최적의 위치를 고를 수 있었습니다.참고로 광고는 재생 중인 동영상의 오른쪽 아래에서 원래 영상과 동시에 재생되는 PIP(Picture in Picture) 형태로 제공됩니다.\n\n\n\n다음은 “죠르디”가 공익광고가 삽입될 최적의 위치를 고르는 과정을 그림으로 설명한 것입니다.\n\n\n\n\n  그림의 파란색 선은 광고를 검토 중인 “죠르디” 동영상의 전체 재생 구간을 나타냅니다.\n    \n      위 그림에서, “죠르디” 동영상의 총 재생시간은 02시간 03분 55초 입니다.\n    \n  \n  그림의 검은색 선들은 각 시청자들이 “죠르디”의 동영상을 재생한 구간의 위치를 표시하고 있습니다.\n    \n      검은색 선의 가운데 숫자는 각 재생 기록을 구분하는 ID를 나타냅니다.\n      검은색 선에 표기된 왼쪽 끝 숫자와 오른쪽 끝 숫자는 시청자들이 재생한 동영상 구간의 시작 시각과 종료 시각을 나타냅니다.\n      위 그림에서, 3번 재생 기록은 00시 25분 50초 부터 00시 48분 29초 까지 총 00시간 22분 39초 동안 죠르디의 동영상을 재생했습니다.\n      위 그림에서, 1번 재생 기록은 01시 20분 15초 부터 01시 45분 14초 까지 총 00시간 24분 59초 동안 죠르디의 동영상을 재생했습니다.\n    \n  \n  그림의 빨간색 선은 “죠르디”가 선택한 최적의 공익광고 위치를 나타냅니다.\n    \n      만약 공익광고의 재생시간이 00시간 14분 15초라면, 위의 그림처럼 01시 30분 59초 부터 01시 45분 14초 까지 공익광고를 삽입하는 것이 가장 좋습니다. 이 구간을 시청한 시청자들의 누적 재생시간이 가장 크기 때문입니다.\n      01시 30분 59초 부터 01시 45분 14초 까지의 누적 재생시간은 다음과 같이 계산됩니다.\n        \n          01시 30분 59초 부터 01시 37분 44초 까지 : 4번, 1번 재생 기록이 두차례 있으므로 재생시간의 합은 00시간 06분 45초 X 2 = 00시간 13분 30초\n          01시 37분 44초 부터 01시 45분 14초 까지 : 4번, 1번, 5번 재생 기록이 세차례 있으므로 재생시간의 합은 00시간 07분 30초 X 3 = 00시간 22분 30초\n          따라서, 이 구간 시청자들의 누적 재생시간은 00시간 13분 30초 + 00시간 22분 30초 = 00시간 36분 00초입니다.\n        \n      \n    \n  \n\n\n\n\n[문제]\n\n“죠르디”의 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time, 시청자들이 해당 동영상을 재생했던 구간 정보 logs가 매개변수로 주어질 때, 시청자들의 누적 재생시간이 가장 많이 나오는 곳에 공익광고를 삽입하려고 합니다. 이때, 공익광고가 들어갈 시작 시각을 구해서 return 하도록 solution 함수를 완성해주세요. 만약, 시청자들의 누적 재생시간이 가장 많은 곳이 여러 곳이라면, 그 중에서 가장 빠른 시작 시각을 return 하도록 합니다.\n\n[제한사항]\n\n\n  play_time, adv_time은 길이 8로 고정된 문자열입니다.\n    \n      play_time, adv_time은 HH:MM:SS 형식이며, 00:00:01 이상 99:59:59 이하입니다.\n      즉, 동영상 재생시간과 공익광고 재생시간은 00시간 00분 01초 이상 99시간 59분 59초 이하입니다.\n      공익광고 재생시간은 동영상 재생시간보다 짧거나 같게 주어집니다.\n    \n  \n  logs는 크기가 1 이상 300,000 이하인 문자열 배열입니다.\n    \n      logs 배열의 각 원소는 시청자의 재생 구간을 나타냅니다.\n      logs 배열의 각 원소는 길이가 17로 고정된 문자열입니다.\n      logs 배열의 각 원소는 H1:M1:S1-H2:M2:S2 형식입니다.\n        \n          H1:M1:S1은 동영상이 시작된 시각, H2:M2:S2는 동영상이 종료된 시각을 나타냅니다.\n          H1:M1:S1는 H2:M2:S2보다 1초 이상 이전 시각으로 주어집니다.\n          H1:M1:S1와 H2:M2:S2는 play_time 이내의 시각입니다.\n        \n      \n    \n  \n  시간을 나타내는 HH, H1, H2의 범위는 00~99, 분을 나타내는 MM, M1, M2의 범위는 00~59, 초를 나타내는 SS, S1, S2의 범위는 00~59까지 사용됩니다. 잘못된 시각은 입력으로 주어지지 않습니다. (예: 04:60:24, 11:12:78, 123:12:45 등)\n  return 값의 형식\n    \n      공익광고를 삽입할 시각을 HH:MM:SS 형식의 8자리 문자열로 반환합니다.\n    \n  \n\n\n\n\n[입출력 예]\n\n\n  \n    \n      play_time\n      adv_time\n      logs\n      result\n    \n  \n  \n    \n      “02:03:55”\n      “00:14:15”\n      [“01:20:15-01:45:14”, “00:40:31-01:00:00”, “00:25:50-00:48:29”, “01:30:59-01:53:29”, “01:37:44-02:02:30”]\n      “01:30:59”\n    \n    \n      “99:59:59”\n      “25:00:00”\n      [“69:59:59-89:59:59”, “01:00:00-21:00:00”, “79:59:59-99:59:59”, “11:00:00-31:00:00”]\n      “01:00:00”\n    \n    \n      “50:00:00”\n      “50:00:00”\n      [“15:36:51-38:21:49”, “10:14:18-15:36:51”, “38:21:49-42:51:45”]\n      “00:00:00”\n    \n  \n\n\n입출력 예에 대한 설명\n\n\n\n입출력 예 #1문제 예시와 같습니다.\n\n입출력 예 #2\n\n\n\n01:00:00에 공익광고를 삽입하면 26:00:00까지 재생되며, 이곳이 가장 좋은 위치입니다. 이 구간의 시청자 누적 재생시간은 다음과 같습니다.\n\n\n  01:00:00-11:00:00 : 해당 구간이 1회(2번 기록) 재생되었으므로 누적 재생시간은 10시간 00분 00초 입니다.\n  11:00:00-21:00:00 : 해당 구간이 2회(2번, 4번 기록) 재생되었으므로 누적 재생시간은 20시간 00분 00초 입니다.\n  21:00:00-26:00:00 : 해당 구간이 1회(4번 기록) 재생되었으므로 누적 재생시간은 05시간 00분 00초 입니다.\n  따라서, 이 구간의 시청자 누적 재생시간은 10시간 00분 00초 + 20시간 00분 00초 + 05시간 00분 00초 = 35시간 00분 00초 입니다.\n  초록색으로 표시된 구간(69:59:59-94:59:59)에 광고를 삽입해도 동일한 결과를 얻을 수 있으나, 01:00:00이 69:59:59 보다 빠른 시각이므로, &quot;01:00:00&quot;을 return 합니다.\n\n\n입출력 예 #3\n\n\n\n동영상 재생시간과 공익광고 재생시간이 같으므로, 삽입할 수 있는 위치는 맨 처음(00:00:00)이 유일합니다.\n\n\n\n\n  동영상 재생시간 = 재생이 종료된 시각 - 재생이 시작된 시각(예를 들어, 00시 00분 01초부터 00시 00분 10초까지 동영상이 재생되었다면, 동영상 재생시간은 9초 입니다.)\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  우선 시간 계산을 효율적으로 하기 위해서 시, 분 단위를 초로 변경해야 겠다고 생각했습니다.\n  로그 데이터의 합집합을 구하는 방식이 좋은 접근이라고 생각했습니다.\n  리스트(배열)로 전체 영상 길이 구조를 만들어서 연산을 진행해야 한다고 생각이 들었습니다.\n\n\n\n  \n    로그 데이터의 합집합을 따로 구하기 보다는 리스트(배열) 구조에 시청자 수를 매핑하는 방식이 효율적\n    리스트(배열) 구조를  잘 정제하여 브루트 포스 사용\n    결과는 영상 구간중 시청자 수가 가장 많은 구간\n  \n\n\n[코드]\n\ndef solution(play_time, adv_time, logs):\n    if play_time == adv_time:\n        return &#39;00:00:00&#39;\n\n    # 문자열 시간 -&amp;gt; 인트형 초단위\n    str_to_int = lambda s: (int(s[:2]) * 3600) + (int(s[3:5]) * 60) + (int(s[6:]))\n    # 인트형 초단위 -&amp;gt; 문자열 시간\n    int_to_str = lambda i: f&#39;{str(i // 3600).zfill(2)}:{str(i % 3600 // 60).zfill(2)}:{str(i % 3600 % 60).zfill(2)}&#39;\n\n    # 영상 전체 길이 초단위 변환\n    playSec = str_to_int(play_time)\n    # 광고 길이 초단위 변환\n    advSec = str_to_int(adv_time)\n    # 영상 전체 길이 구조 생성\n    total = [0 for _ in range(playSec + 1)]\n\n    # 시청 기록 시작, 끝 시간을 영상 전체 길이 구조에 기록\n    for log in logs:\n        s_l, e_l = log.split(&#39;-&#39;)\n        start = str_to_int(s_l)\n        end = str_to_int(e_l)\n        total[start] += 1\n        total[end] -= 1\n\n    # 시청자 수를 영상 길이 구조에 기록\n    for i in range(1, playSec):\n        total[i] += total[i-1]\n\n    new_sum = sum(total[:advSec])\n    # 광고 영상 길이동안 총 시청자 수\n    max_sum = new_sum\n    # 총 시청자 수가 max인 인덱스\n    max_idx = 0\n\n    # 광고 영상 끝 시간 ~ 영상 전체 길이 구간동안 반복\n    # -&amp;gt; new_sum을 구하며 광고 영상 끝 시간 이전은 연산 했기 때문에 제외\n    for i in range(advSec, playSec):\n        # 인덱스 1칸 이동하며 시청자 수 계산\n        new_sum = new_sum + total[i] - total[i-advSec]\n        if max_sum &amp;lt; new_sum:\n            max_sum = new_sum\n            max_idx = i - advSec + 1\n\n    answer = int_to_str(max_idx)\n\n    return answer\n\n\n[여담]\n\n다른 사람의 풀이를 보았을 때, 대부분 비슷한 방식으로 문제를 해결했다. 그래서 점점 브루트 포스 유형의 문제에 익숙해지고 있는 느낌이 들었습니다.\n\n그리고 문제를 풀고나서 다른 사람의 풀이에서 배열 생성을 곱하기 방식을 사용하는 것을 보고, 컴프리헨션을 이용한 배열 생생과 곱하기를 통한 생성 중 어떤 방식이 더 빠를지 테스트를 진행했습니다.\n\nfrom time import time\n\nst1 = time()\nresult1 = [0 for _ in range(36001)]\net1 = time() - st1\n\nst2 = time()\nresult2 = [0] * len(result1)\net2 = time() - st2\n\nprint(f&#39;result1 : {et1}&#39;)\nprint(f&#39;result2 : {et2}&#39;)\n\n결과는 곱하기를 통한 배열 생성이 속도면에서 10배 이상 빠른 것을 확인할 수 있었습니다.\n\n이제 단순 배열은 곱하기 연산을 통해 생성하는게 효율면에서 좋을 것이라고 생각이 들었습니다.\n\n\n"
} ,
  
  {
    "title"    : "함수형 프로그래밍 (Functional Programming)-1",
    "category" : "",
    "tags"     : " 기본기",
    "url"      : "/2021/07/25/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Functional-Programming.html",
    "date"     : "July 25, 2021",
    "excerpt"  : "\n\n함수형 프로그래밍이란 순수 함수(Pure Function)를 통해 자료 처리를 수학적 함수의 계산으로 취급하고, 상태와 가변 데이터를 멀리하여 부작용(Side-Effect)을 최소화며 프로그래밍하는 패러다임입니다.\n\n이전에 포스팅한 객체지향 프로그래밍과 약간 대조되는 패러다임이라고 생각이 들었습니다.\n\n그 주관적인 이유는 아래와 같습니다.\n\n\n  \n    객체 단위의 효율적인 처리와 다르게 함수 단위의 독립적인 처리 방식을 고집한다.\n...",
  "content"  : "\n\n함수형 프로그래밍이란 순수 함수(Pure Function)를 통해 자료 처리를 수학적 함수의 계산으로 취급하고, 상태와 가변 데이터를 멀리하여 부작용(Side-Effect)을 최소화며 프로그래밍하는 패러다임입니다.\n\n이전에 포스팅한 객체지향 프로그래밍과 약간 대조되는 패러다임이라고 생각이 들었습니다.\n\n그 주관적인 이유는 아래와 같습니다.\n\n\n  \n    객체 단위의 효율적인 처리와 다르게 함수 단위의 독립적인 처리 방식을 고집한다.\n    일급 객체의 기준이 다음과 같다.\n 함수형 - 객체(Object) vs 객체지향 - 함수(Function)\n    복잡한 구조로 구성되는 객체지향 프로그래밍과 달리 아주x2 간결한 구조로 구성된다.\n  \n\n  📌 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 보통 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다.\n\n  “위키백과 - 일급 객체”\n\n\n함수형 프로그래밍에는 몇 가지의 특징적인 함수의 형태와 개념이 존재합니다.\n\n\n  특징적인 함수    \n      1. 순수 함수 (Pure Function)\n      2. 익명 함수 (Anonymous Function)\n      3. 고계 함수 (Higher-Order Function)\n    \n  \n\n\n\n\n특징적인 함수\n\n1. 순수 함수 (Pure Function)\n\n순수 함수는 함수형 프로그래밍을 하기 위해서 반드시 사용해야하는 함수 형태이며, 아래와 같은 특징이 있습니다.\n\n\n  부작용(Side-Effect)이 없는 함수이다.\n  함수의 실행이 외부에 영향을 끼치지 않아야 한다.\n  동일한 입력 값을 넣었을 때는 항상 동일한 값을 반환해야 한다.\n  호출 위치와 상관없이 항상 동일한 값을 반환해야 한다.\n  위의 특징들로 인해서 안정적인 병렬 계산이 가능하다.\n\n\n2. 익명 함수 (Anonymous Function)\n\n익명 함수는 이름이 없는 함수를 말한다. 생성 즉시 실행되기 때문에 초기화 같은 작업에 효과적으로 사용되는 함수 형태이며, 아래와 같은 특징이 있습니다.\n\n\n  일회성 함수이다.\n  \n    선언 이전에 사용될 수 없다.\n\n    \n      📌 Javascript의 경우에는 호이스팅으로 인해서 선언 이전에도 함수를 사용할 수 있지만, 익명 함수의 경우에는 호이스팅이 적용되지 않아서 선언 이후에 사용해야 한다.\n    \n  \n  람다(Lambda)식을 통해 익명 함수를 수행할 수 있다.\n\n\n3. 고계 함수 (Higher-Order Function)\n\n고계 함수 는 함수 자체도 값(value) 으로 취급하여 사용하는 함수 형태이며, 아래와 같은 특징이 있습니다.\n\n\n  함수를 다른 함수의 입력 값으로 전달할 수 있다.\n  함수의 반환 값 역시 함수로 반환할 수 있다.\n\n\n\n  📌 함수형 프로그래밍-2 에서 이어서 포스팅 하도록 하겠습니다.\n\n"
} ,
  
  {
    "title"    : "[카카오 코딩 테스트] 합승 택시 요금",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/07/24/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%A9%EC%8A%B9-%ED%83%9D%EC%8B%9C-%EC%9A%94%EA%B8%88.html",
    "date"     : "July 24, 2021",
    "excerpt"  : "\n\n2021 KAKAO BLIND RECRUITMENT “합승 택시 요금” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]\n\n밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던 무지는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. “무지”는 자신이 택시를 이용할 때 동료인 어...",
  "content"  : "\n\n2021 KAKAO BLIND RECRUITMENT “합승 택시 요금” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n문제 설명\n\n[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]\n\n밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던 무지는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. “무지”는 자신이 택시를 이용할 때 동료인 어피치 역시 자신과 비슷한 방향으로 가는 택시를 종종 이용하는 것을 알게 되었습니다. “무지”는 “어피치”와 귀가 방향이 비슷하여 택시 합승을 적절히 이용하면 택시요금을 얼마나 아낄 수 있을 지 계산해 보고 “어피치”에게 합승을 제안해 보려고 합니다.\n\n\n\n위 예시 그림은 택시가 이동 가능한 반경에 있는 6개 지점 사이의 이동 가능한 택시노선과 예상요금을 보여주고 있습니다.그림에서 A와 B 두 사람은 출발지점인 4번 지점에서 출발해서 택시를 타고 귀가하려고 합니다. A의 집은 6번 지점에 있으며 B의 집은 2번 지점에 있고 두 사람이 모두 귀가하는 데 소요되는 예상 최저 택시요금이 얼마인 지 계산하려고 합니다.\n\n\n  그림의 원은 지점을 나타내며 원 안의 숫자는 지점 번호를 나타냅니다.\n    \n      지점이 n개일 때, 지점 번호는 1부터 n까지 사용됩니다.\n    \n  \n  지점 간에 택시가 이동할 수 있는 경로를 간선이라 하며, 간선에 표시된 숫자는 두 지점 사이의 예상 택시요금을 나타냅니다.\n    \n      간선은 편의 상 직선으로 표시되어 있습니다.\n      위 그림 예시에서, 4번 지점에서 1번 지점으로(4→1) 가거나, 1번 지점에서 4번 지점으로(1→4) 갈 때 예상 택시요금은 10원으로 동일하며 이동 방향에 따라 달라지지 않습니다.\n    \n  \n  예상되는 최저 택시요금은 다음과 같이 계산됩니다.\n    \n      4→1→5 : A, B가 합승하여 택시를 이용합니다. 예상 택시요금은 10 + 24 = 34원 입니다.\n      5→6 : A가 혼자 택시를 이용합니다. 예상 택시요금은 2원 입니다.\n      5→3→2 : B가 혼자 택시를 이용합니다. 예상 택시요금은 24 + 22 = 46원 입니다.\n      A, B 모두 귀가 완료까지 예상되는 최저 택시요금은 34 + 2 + 46 = 82원 입니다.\n    \n  \n\n\n[문제]\n\n지점의 개수 n, 출발지점을 나타내는 s, A의 도착지점을 나타내는 a, B의 도착지점을 나타내는 b, 지점 사이의 예상 택시요금을 나타내는 fares가 매개변수로 주어집니다. 이때, A, B 두 사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 간다고 가정할 때, 최저 예상 택시요금을 계산해서 return 하도록 solution 함수를 완성해 주세요.만약, 아예 합승을 하지 않고 각자 이동하는 경우의 예상 택시요금이 더 낮다면, 합승을 하지 않아도 됩니다.\n\n[제한사항]\n\n\n  지점갯수 n은 3 이상 200 이하인 자연수입니다.\n  지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.\n    \n      즉, 출발지점, A의 도착지점, B의 도착지점은 서로 겹치지 않습니다.\n    \n  \n  fares는 2차원 정수 배열입니다.\n  fares 배열의 크기는 2 이상 n x (n-1) / 2 이하입니다.\n    \n      예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (6 x 5 / 2 = 15)\n      fares 배열의 각 행은 [c, d, f] 형태입니다.\n      c지점과 d지점 사이의 예상 택시요금이 f원이라는 뜻입니다.\n      지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.\n      요금 f는 1 이상 100,000 이하인 자연수입니다.\n      fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다.\n    \n  \n  출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다.\n\n\n[입출력 예]\n\n\n  \n    \n      n\n      s\n      a\n      b\n      fares\n      result\n    \n  \n  \n    \n      6\n      4\n      6\n      2\n      [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]]\n      82\n    \n    \n      7\n      3\n      4\n      1\n      [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]]\n      14\n    \n    \n      6\n      4\n      5\n      6\n      [[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]]\n      18\n    \n  \n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  이번 문제는 저번에 당했던 효율성 별도 체크 항목 때문에 고민을 좀 더 하면서 풀었습니다.\n  최단 거리 알고리즘(Dijkstra), 우선 탐색 알고리즘(BFS, DFS) 등을 과거에 공부했지만 갑자기 다시 적용을 해보려니까 생각이 잘 나지 않았습니다. → 반복 학습의 필요성을 느낌\n  효율성을 위해 우선순위 큐를 사용해야 한다고 생각이 들었습니다.\n→ 우선순위 큐는 힙큐로 구현 가능\n  그래프 구조를 먼저 만들고, 연산을 진행해야 한다고 생각이 들었습니다.\n\n\n\n  \n    그래프 생성\n    최단 거리 알고리즘 사용 → 다익스트라(Dijkstra)\n    결과는 노드 이동 거리의 가장 작은 합\n  \n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\n# 활용성을 위한 힙큐 라이브러리\nimport heapq\n\ndef solution(n, s, a, b, fares):\n    # 마지막에 크기 비교를 위해 무한대의 값으로 정의\n    answer = float(&#39;inf&#39;)\n    # 입력된 노드의 갯수인 n를 이용해 그래프 구조 생성\n    graph = {i+1: {} for i in range(n)}\n\n    # 그래프 내용 채우기\n    for x, y, z in fares:\n        graph[x][y] = z\n        graph[y][x] = z\n\n    # 다익스트라 알고리즘\n    def dijkstra(start):\n        # 최단 거리를 담기 위한 리스트 배열 생성,\n        # 값 비교를 위해 요소값을 무한대로 정의\n        distances = [float(&#39;inf&#39;) for _ in range(n+1)]\n        # 시작 노드의 거리는 0으로 지정\n        distances[start] = 0\n        queue = []\n        heapq.heappush(queue, [start, 0])\n\n        while queue:\n            # 큐에서 노드와 해당 노드의 거리를 get\n            cur_node, cur_distance = heapq.heappop(queue)\n\n            # 현재 거리가 최단 거리보다 크면 반복문 실행 안함\n            if distances[cur_node] &amp;lt; cur_distance:\n                continue\n\n            # 그래프에서 현재 노드와 연결되어 있는 노드들을 호출하여 거리값 계산\n            for next_node, next_distance in graph[cur_node].items():\n                distance = cur_distance + next_distance\n                # 계산된 거리가 리스트 배열의 거리보다 작은 경우\n                # 리스트 배열에 계산된 거리를 담고,\n                # 힙큐에 해당 노드 추가\n                if distance &amp;lt; distances[next_node]:\n                    distances[next_node] = distance\n                    heapq.heappush(queue, [next_node, distance])\n\n\t\t\t\t# distances -&amp;gt; 최단 거리를 담은 리스트 배열\n        return distances\n\n\t\t# 2차원 배열의 형태로 노드별 최단 거리를 생성\n    d = [dijkstra(i) for i in range(1, n+1)]\n\n    # 합산 거리중 최단 거리를 반환\n    for i in range(n):\n        answer = min(answer, d[i][s] + d[i][a] + d[i][b])\n\n    return answer\n\n\n[여담]\n\n점점 문제의 의도를 파악하는 시간이 줄어들고 있어서 문제풀이 행위에 대해서 자체적인 만족을 느꼈습니다.\n\n이번 문제는 다익스트라(Dijkstra) 뿐만 아니라 플로이드 와샬(Floyd Warshall) 알고리즘 풀이도 가능했습니다.\n\n아래는 플로이드 와샬(Floyd Warshall) 알고리즘으로 풀이한 코드입니다.\n\nimport heapq\n\ndef solution(n, s, a, b, fares):\n    d = [ [ 20000001 for _ in range(n) ] for _ in range(n) ]\n    for x in range(n):\n        d[x][x] = 0\n    for x, y, c in fares:\n        d[x-1][y-1] = c\n        d[y-1][x-1] = c\n\n    # k라는 경로를 거쳐가며 계산을 한다.\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if d[j][k] &amp;gt; d[j][i] + d[i][k]:\n                    d[j][k] = d[j][i] + d[i][k]\n\n    minv = 40000002\n    for i in range(n):\n        minv = min(minv, d[s-1][i]+d[i][a-1]+d[i][b-1])\n    return minv\n\n"
} ,
  
  {
    "title"    : "[Design Pattern] 전략 패턴 (Strategy)",
    "category" : "",
    "tags"     : " 디자인패턴",
    "url"      : "/2021/07/23/Designe-Pattern-Strategy.html",
    "date"     : "July 23, 2021",
    "excerpt"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다.\n\n  \n    특정한 계열의 알고리즘들을 정의\n    각 알고리즘을 캡슐화\n    알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만듬\n  \n\n  Strategy는 알고리즘을 사용하는 클라이언트와는 독립적으로 다양하게 만든다. Strategy는 유연하고 재사용 가능한 객체지향 소프트웨어를 어떻게 설계하...",
  "content"  : "\n\n설명\n\n위키백과에 나온 내용은 다음과 같습니다.\n\n\n  실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다.\n\n  \n    특정한 계열의 알고리즘들을 정의\n    각 알고리즘을 캡슐화\n    알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만듬\n  \n\n  Strategy는 알고리즘을 사용하는 클라이언트와는 독립적으로 다양하게 만든다. Strategy는 유연하고 재사용 가능한 객체지향 소프트웨어를 어떻게 설계하는지 기술하기 위해 디자인 패턴의 개념을 보급시킨 디자인 패턴이라는 영향력 있는 책에 포함된 패턴들 가운데 하나이다. (GoF 행위에 포함)\n\n  “위키백과 - Strategy Pattern”\n\n\n\n  객체지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴이라고 합니다.\n  위키백과의 설명을 보면 알고리즘의 캡슐화를 통해 실행중에 알고리즘을 바꿔가며 사용하는 방식입니다.\n  Strategy는 하나의 시스템에서 설정이 각각 다른 여러 모듈을 사용할 때 설정의 공통 부분에 이용하면 좋을 것 같다고 생각이 들었습니다.\n\n\n예시 코드\n\n클래스 선언시에 parameter가 없으면 클래스 내부 함수 호출, parameter가 있으면 전달받은 함수 호출\n\nclass Strategy():\n    # Python은 함수도 parameter로 전달하고, 전달받을 수 있다.\n    def __init__(self, obj=None):\n        # obj가 있으면 self.getFunction()에 할당\n        if obj:\n            self.getFunction = obj\n\n    def getFunction(self):\n        return &#39;Internal Function&#39;\n\ndef outFunction1():\n    return &#39;External Function 1&#39;\n\ndef outFunction2():\n    return &#39;External Function 2&#39;\n\nif __name__ == &#39;__main__&#39;:\n    strategy0 = Strategy()\n    strategy1 = Strategy(outFunction1)\n    strategy2 = Strategy(outFunction2)\n\n    print(f&#39;strategy0: {strategy0.getFunction()}&#39;)\n    print(f&#39;strategy1: {strategy1.getFunction()}&#39;)\n    print(f&#39;strategy2: {strategy2.getFunction()}&#39;)\n\n\n실행 결과\n\nstrategy0, 1, 2의 결과가 각각 다른 것을 확인할 수 있습니다.\n\n\n"
} ,
  
  {
    "title"    : "[Design Pattern] 싱글턴 패턴 (Singleton)",
    "category" : "",
    "tags"     : " 디자인패턴",
    "url"      : "/2021/07/21/Designe-Pattern-Singleton.html",
    "date"     : "July 21, 2021",
    "excerpt"  : "\n\n설명\n\n먼저 위키백과의 설명을 한 번 보겠습니다.\n\n\n  클래스의 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고, 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴하는 방식의 디자인 유형을 Singleton 패턴이라고 한다. (GoF 생성에 포함)\n\n  “위키백과 - Singleton Pattern”\n\n\n\n  위키백과의 설명처럼 특정 객체를 여러곳에서 공유하기 위해서 사용하는 방식입니다.\n  Pyt...",
  "content"  : "\n\n설명\n\n먼저 위키백과의 설명을 한 번 보겠습니다.\n\n\n  클래스의 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고, 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴하는 방식의 디자인 유형을 Singleton 패턴이라고 한다. (GoF 생성에 포함)\n\n  “위키백과 - Singleton Pattern”\n\n\n\n  위키백과의 설명처럼 특정 객체를 여러곳에서 공유하기 위해서 사용하는 방식입니다.\n  Python은 모듈 자체가 Singleton으로 구성되어있습니다.\n→ 클래스 변수를 생성하면 해당 클래스의 객체가 생성된 어느 곳이던 같은 변수값이 반환됩니다.\n  Singleton은 다크 모드 같은 시스템 상의 공용 설정에 이용하면 좋을 것 같다고 생각이 들었습니다.\n\n\n예시 코드\n\n클래스 객체 생성시에 instance란 변수가 없으면 변수를 생성, 있으면 그냥 반환\n\n# test_singleton.py\n\nclass Singleton():\n    def __new__(cls):\n        # instance 존재 여부 확인\n        if not hasattr(cls, &#39;instance&#39;):\n            cls.instance = super(Singleton, cls).__new__(cls)\n        return cls.instance\n\nif __name__ == &#39;__main__&#39;:\n    single_1 = Singleton()\n    print(f&#39;1번 세팅 : {single_1}&#39;)\n    single_2 = Singleton()\n    print(f&#39;2번 세팅 : {single_2}&#39;)\n\n\n실행 결과\n\n객체를 2번 생성시 최초 생성한 객체(1번)와 동일한 객체를 반환 받은 것을 확인할 수 있습니다.\n\n\n"
} ,
  
  {
    "title"    : "[카카오 코딩 테스트] 순위 검색",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/07/20/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%88%9C%EC%9C%84-%EA%B2%80%EC%83%89.html",
    "date"     : "July 20, 2021",
    "excerpt"  : "\n\n2021 KAKAO BLIND RECRUITMENT “메뉴 리뉴얼” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]\n\n카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.\n\n\n  코딩테스트 ...",
  "content"  : "\n\n2021 KAKAO BLIND RECRUITMENT “메뉴 리뉴얼” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]\n\n카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.\n\n\n  코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다.\n  지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다.\n  지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다.\n  선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다.\n\n\n인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?\n\n물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.\n\n\n  코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?\n  코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?\n  backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가?\n  소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가?\n  코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가?\n\n\n즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.\n\n\n  [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\n\n\n\n\n[문제]\n\n지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.\n\n[제한사항]\n\n\n  info 배열의 크기는 1 이상 50,000 이하입니다.\n  info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 “개발언어 직군 경력 소울푸드 점수” 형식입니다.\n    \n      개발언어는 cpp, java, python 중 하나입니다.\n      직군은 backend, frontend 중 하나입니다.\n      경력은 junior, senior 중 하나입니다.\n      소울푸드는 chicken, pizza 중 하나입니다.\n      점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다.\n      각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.\n    \n  \n  query 배열의 크기는 1 이상 100,000 이하입니다.\n  query의 각 문자열은 “[조건] X” 형식입니다.\n    \n      [조건]은 “개발언어 and 직군 and 경력 and 소울푸드” 형식의 문자열입니다.\n      언어는 cpp, java, python, - 중 하나입니다.\n      직군은 backend, frontend, - 중 하나입니다.\n      경력은 junior, senior, - 중 하나입니다.\n      소울푸드는 chicken, pizza, - 중 하나입니다.\n      ’-‘ 표시는 해당 조건을 고려하지 않겠다는 의미입니다.\n      X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다.\n      각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.\n      예를 들면, “cpp and - and senior and pizza 500”은 “cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?”를 의미합니다.\n    \n  \n\n\n[입출력 예]\n\n\n  \n    \n      info\n      query\n      result\n    \n  \n  \n    \n      [“java backend junior pizza 150”,”python frontend senior chicken 210”,”python frontend senior chicken 150”,”cpp backend senior pizza 260”,”java backend junior chicken 80”,”python backend senior chicken 50”]\n      [“java and backend and junior and pizza 100”,”python and frontend and senior and chicken 200”,”cpp and - and senior and pizza 250”,”- and backend and senior and - 150”,”- and - and - and chicken 100”,”- and - and - and - 150”]\n      [1,1,1,1,2,4]\n    \n  \n\n\n입출력 예에 대한 설명\n지원자 정보를 표로 나타내면 다음과 같습니다.\n\n\n  \n    \n      언어\n      직군\n      경력\n      소울푸드\n      점수\n    \n  \n  \n    \n      java\n      backend\n      junior\n      pizza\n      150\n    \n    \n      python\n      frontend\n      senior\n      chicken\n      210\n    \n    \n      python\n      frontend\n      senior\n      chicken\n      150\n    \n    \n      cpp\n      backend\n      senior\n      pizza\n      260\n    \n    \n      java\n      backend\n      junior\n      chicken\n      80\n    \n    \n      python\n      backend\n      senior\n      chicken\n      50\n    \n  \n\n\n\n  &quot;java and backend and junior and pizza 100&quot; : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다.\n  &quot;python and frontend and senior and chicken 200&quot; : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다.\n  &quot;cpp and - and senior and pizza 250&quot; : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다.\n  &quot;- and backend and senior and - 150&quot; : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다.\n  &quot;- and - and - and chicken 100&quot; : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다.\n  &quot;- and - and - and - 150&quot; : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.\n\n\n\n\nSolution\n\n[문제 이해]\n\n\n  이번 문제는 처음에 정확도를 맞추는 것은 크게 어렵지 않았는데, 효율성 부분에서 꽤 많은 시간이 걸리다가, 효율성 부분은 결국 검색을 통해 해결했습니다.\n  최초 시도에는 단순히 리스트 컴프리헨션을 사용하며, 반복문을 최소화 하는 방식으로 진행했습니다.\n→ 정확도는 맞았지만 효율성에서 실패하기 시작\n  \n    아래는 시도했던 방법입니다.\n\n    \n      \n        리스트 컴프리헨션 → 효율성 실패\n        list보다 빠르 처리를 위해 dictionary 사용 → 효율성 실패\n        셀프 lower bound 사용 → 효율성 실패\n        구체적인 문제 풀이 검색 : https://pacientes.github.io/posts/2021/02/algorithm_programmers_72412/\n→ 처리할 데이터의 형태가 간단하다면 구조를 미리 만들어두고 최소한의 비교를 통해 결론을 도출 → 효율성 성공\n      \n    \n  \n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\n# Lower bound를 사용하기 위한 라이브러리\nfrom bisect import bisect_left\n\ndef solution(info, query):\n    answer = []\n    \n    language = [&#39;cpp&#39;, &#39;java&#39;, &#39;python&#39;, &#39;-&#39;]\n    position = [&#39;backend&#39;, &#39;frontend&#39;, &#39;-&#39;]\n    career = [&#39;junior&#39;, &#39;senior&#39;, &#39;-&#39;]\n    soulfood = [&#39;chicken&#39;, &#39;pizza&#39;, &#39;-&#39;]\n\n    # 데이터 처리 효율을 위해 미리 만들어둘 구조\n    tables = {}\n    for lang in language:\n        for posi in position:\n            for ca in career:\n                for fo in soulfood:\n                    tables[lang + posi + ca + fo] = []\n\n    # 입력된 info 데이터 전처리\n    for i in info:\n        i = i.split()\n        language = [i[0], &#39;-&#39;]\n        position = [i[1], &#39;-&#39;]\n        career = [i[2], &#39;-&#39;]\n        soulfood = [i[3], &#39;-&#39;]\n\n        for lang in language:\n            for posi in position:\n                for ca in career:\n                    for fo in soulfood:\n                        tables[lang + posi + ca + fo].append(int(i[4]))\n\n    # 데이터 정렬 -&amp;gt; Lower bound를 사용하기 위함\n    for k in tables:\n        tables[k].sort()\n\n    # 입력된 query 데이터 전처리\n    for q in query:\n        q, score = q.replace(&#39; and &#39;, &#39;&#39;).split()\n        score = int(score)\n        \n        left = 0\n        right = len(tables[q])\n\n        # Lower bound를 사용하여 불필요한 데이터 처리를 최소화\n        while left &amp;lt; right:\n            mid = (left + right) // 2\n            if tables[q][mid] &amp;gt;= score: right = mid\n            else: left = mid + 1\n        # 전처리된 info의 list 데이터의 갯수에서 불필요한 데이터를 뺀다.\n        answer.append(len(tables[q]) - left)\n\n    return answer\n\n\n[여담]\n\n문제풀이가 끝난뒤에 다른 사람들의 풀이를 보았는데 역시 대단한 사람들을 또 한번 볼 수 있었습니다.\n그리고 내가 푼 방식이(검색해서 풀었지만) 문제의 의도에 많이 근접했다고 느껴졌습니다.\n\n아래는 가장 놀라웠던 숏코딩 을 작성한 코드입니다.\n이 분은 친철하게 풀이 과정까지 깃헙에 올려주셔서 링크를 첨부합니다.\nReference - https://github.com/yuneg11/Programmers-Solutions/tree/master/solutions/72412 - 순위 검색\n\nfrom functools import reduce\nfrom collections import defaultdict\nfrom bisect import insort, bisect_left\n\ndef solution(info, query):\n    table = {&quot;c&quot;: 3, &quot;j&quot;: 5, &quot;p&quot;: 6, &quot;b&quot;: 6, &quot;f&quot;: 5, &quot;s&quot;: 6, &quot;-&quot;: 0}\n    conv = lambda l, t: (reduce(lambda a, k: (a &amp;lt;&amp;lt; 3) + t(table[k[0]]), l[:-1], 0), int(l[-1]))\n    info = list(map(lambda s: conv(s.split(&quot; &quot;), lambda x: 7 - x), info))\n    query = list(map(lambda s: conv([c for c in s.split(&quot; &quot;) if c != &quot;and&quot;], lambda x: x), query))\n    d = defaultdict(list)\n    for k, v in info:\n        insort(d[k], v)\n    return [sum([len(l) - bisect_left(l, v) for k, l in d.items() if not k &amp;amp; q]) for q, v in query]\n\n"
} ,
  
  {
    "title"    : "객체지향 프로그래밍(Object Oriented Programming)",
    "category" : "",
    "tags"     : " 기본기",
    "url"      : "/2021/07/16/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Object-Oriented-Programming.html",
    "date"     : "July 16, 2021",
    "excerpt"  : "\n\n객체지향 프로그래밍(OOP)이란 프로그래밍 패러다임의 하나입니다.\n\n객체지향의 객체(Object) 란 데이터(정보, 속성 등)와 데이터를 처리하는 기능(함수)이 클래스로 캡슐화 된 컴퓨터 자원의 묶음(모듈)을 객체 라고 합니다.\n\n결국 객체지향 프로그래밍이란 현실의 문제를 여러 개의 객체 단위로 구분하여 처리하는 방식을 말한다고 할 수 있습니다.\n\n객체지향 프로그래밍하면 주로 나오는 키워드가 있습니다.\n\n\n  1. 캡슐화 (Encaps...",
  "content"  : "\n\n객체지향 프로그래밍(OOP)이란 프로그래밍 패러다임의 하나입니다.\n\n객체지향의 객체(Object) 란 데이터(정보, 속성 등)와 데이터를 처리하는 기능(함수)이 클래스로 캡슐화 된 컴퓨터 자원의 묶음(모듈)을 객체 라고 합니다.\n\n결국 객체지향 프로그래밍이란 현실의 문제를 여러 개의 객체 단위로 구분하여 처리하는 방식을 말한다고 할 수 있습니다.\n\n객체지향 프로그래밍하면 주로 나오는 키워드가 있습니다.\n\n\n  1. 캡슐화 (Encapsulation)\n  2. 상속성 (Inheritance)\n  3. 추상화 (Abstraction)\n  4. 다형성 (Polymorphism)\n\n\n1. 캡슐화 (Encapsulation)\n\n캡슐화는 데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미하며, 아래와 같은 특징이 있습니다.\n\n\n  캡슐화된 객체 내부는 은닉되어 외부로부터 독립적이다.\n  독립적인 객체는 외부 모듈에 의한 영향이 적다.\n  독립적이기 때문에 객체 간의 결합도가 낮다.\n  캡슐화된 객체는 재사용이 용이하다.\n\n\n2. 상속성 (Inheritance)\n\n상속성은 이미 정의된 상위 개념의 특징을 하위 개념이 물려받는 것을 의미하며, 아래와 같은 특징이 있습니다.\n\n\n  상속을 통해 상위 개념의 특징을 공유하기 때문에 재사용이 용이하다.\n  이미 정의된 개념을 하위 개념에서 상속받기 때문에 중복되는 코드 작성을 방지한다.\n  상속받은 특징 외에 새로운 특징을 추가하여 사용할 수 있다.\n\n\n3. 추상화 (Abstraction)\n\n추상화는 객체의 공통 특징이나 기능을 묶어서 통상적으로 표현하는 것을 의미하며, 아래와 같은 특징이 있습니다.\n\n\n  코드의 중복 작성을 방지하고, 가독성을 높여준다.\n  추상화를 통하면 재사용이 용이하다.\n\n\n4. 다형성 (Polymorphism)\n\n다형성은 하나의 시그널을 각 객체가 가지고 있는 고유 특성으로 처리 가능하게 구성하는 것을 의미하며, 아래와 같은 특징이 있습니다.\n\n\n  시그널의 형태가 달라지면 처리되는 방식도 달라진다.\n  오버로딩, 오버라이딩 같은 기법을 사용하여 효율적인 작업이 가능하다.\n    \n      📌 Python에서는 오버로딩 기능이 지원되지 않는다.\n    \n  \n\n"
} ,
  
  {
    "title"    : "[Python] 컴프리헨션(Comprehention)",
    "category" : "",
    "tags"     : " Python",
    "url"      : "/2021/07/15/%EC%BB%B4%ED%94%84%EB%A6%AC%ED%97%A8%EC%85%98-Comprehention.html",
    "date"     : "July 15, 2021",
    "excerpt"  : "\n\n컴프리헨션이란?\n\n\n  Python에서 컴프리헨션(Comprehension)이란 list, dictionary, set의 자료구조를 보다 쉽게 저장, 검색을 할 수 있게 하는 문법입니다.\n  컴프리헨션은 list, dictionary, set의 내부에 코드를 작성하는 특징이 있습니다.\n\n\n\n  ⚠️ 컴프리헨션은 입력 시퀀스에 있는 값 별로 객체를 담은 자료구조를 통째로 생성하기 때문에 메모리가 많이 소모될 수 있습니다.\n→ 하지만 이런...",
  "content"  : "\n\n컴프리헨션이란?\n\n\n  Python에서 컴프리헨션(Comprehension)이란 list, dictionary, set의 자료구조를 보다 쉽게 저장, 검색을 할 수 있게 하는 문법입니다.\n  컴프리헨션은 list, dictionary, set의 내부에 코드를 작성하는 특징이 있습니다.\n\n\n\n  ⚠️ 컴프리헨션은 입력 시퀀스에 있는 값 별로 객체를 담은 자료구조를 통째로 생성하기 때문에 메모리가 많이 소모될 수 있습니다.\n→ 하지만 이런 문제를 해결하기 위해서 Python에서는 제너레이터 표현식을 사용합니다.\n\n\n\n\n컴프리헨션 표현식 형태\n\nList       : [표현식 for 객체 in 순회가능객체] + 조건, 다중 반복문\nDictionary : {키_표현식 : 값_표현식 for 객체 in 순회가능객체} + 조건, 다중 반복문\nSet        : {표현식 for 객체 in 순회가능객체} + 조건, 다중 반복문\n\n\n\n  \n    리스트 컴프리헨션 (List Comprehension)\n\n      var_list = []\n\t\n  for i in range(5):\n      var_list.append(i+1)\n\t\n  print(var_list)\n  ---------------------------------------------------\n  [1, 2, 3, 4, 5]\n    \n\n    위의 코드는 반복문을 통해 1 ~ 5의 숫자를 갖는 list를 생성하는 코드입니다.\n  아래는 위의 코드와 동일하게 list를 생성하는 컴프리헨션입니다.\n\n      var_list = [i+1 for i in range(5)]\n\t\n  print(var_list)\n  ---------------------------------------------------\n  [1, 2, 3, 4, 5]\n    \n  \n  \n    딕셔너리 컴프리헨션 (Dictionary Comprehention)\n\n      students = [&#39;짱구&#39;, &#39;철수&#39;, &#39;유리&#39;, &#39;훈이&#39;, &#39;맹구&#39;]\n  var_dict = {}\n\t\n  for name in students:\n      var_dict[name] = &#39;human&#39;\n\t\n  print(var_dict)\n  ---------------------------------------------------\n  {&#39;짱구&#39;: &#39;human&#39;, &#39;철수&#39;: &#39;human&#39;, &#39;유리&#39;: &#39;human&#39;, &#39;훈이&#39;: &#39;human&#39;, &#39;맹구&#39;: &#39;human&#39;}\n    \n\n    위의 코드는 students의 학생들을 key 로 ‘human’을 value 를 할당하는 dictionary를 생성하는 코드입니다.\n  아래는 위의 코드와 동일하게 dictionary를 생성하는 컴프리헨션입니다.\n\n      students = [&#39;짱구&#39;, &#39;철수&#39;, &#39;유리&#39;, &#39;훈이&#39;, &#39;맹구&#39;]\n  var_dict = {name: &#39;human&#39; for name in students}\n\t\n  print(var_dict)\n  ---------------------------------------------------\n  {&#39;짱구&#39;: &#39;human&#39;, &#39;철수&#39;: &#39;human&#39;, &#39;유리&#39;: &#39;human&#39;, &#39;훈이&#39;: &#39;human&#39;, &#39;맹구&#39;: &#39;human&#39;}\n    \n  \n  \n    셋 컴프리헨션 (Set Comprehention)\n\n      var_set = set()\n\t\n  for i in range(5):\n      var_set.add(i+1)\n\t\n  print(var_set)\n  ---------------------------------------------------\n  {3, 2, 1, 5, 4}\n    \n\n    위의 코드는 반복문을 통해 1 ~ 5의 숫자를 갖는 set(집합)을 생성하는 코드입니다.\n  set(집합)은 괄호의 형태가 dictionary와 동일하기 때문에 {} 를 사용하지 않고 set() 을 사용하여 선언합니다.\n  아래는 위의 코드와 동일하게 set(집합)을 생성하는 컴프리헨션입니다.\n\n      var_set = {i+1 for i in range(5)}\n\t\n  print(var_set)\n  ---------------------------------------------------\n  # set은 데이터의 순서를 구분하지 않아서 출력시 순서가 일정하지 않다.\n  {2, 5, 3, 1, 4}\n    \n  \n\n"
} ,
  
  {
    "title"    : "[카카오 코딩 테스트] 메뉴 리뉴얼",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/07/14/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC.html",
    "date"     : "July 14, 2021",
    "excerpt"  : "\n\n2021 KAKAO BLIND RECRUITMENT “메뉴 리뉴얼” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n[문제 설명]\n\n레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.\n기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋...",
  "content"  : "\n\n2021 KAKAO BLIND RECRUITMENT “메뉴 리뉴얼” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n[문제 설명]\n\n레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.\n기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 “스카피”는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.\n단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다.\n\n예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,\n(각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.)\n\n\n  \n    \n      손님 번호\n      주문한 단품메뉴 조합\n    \n  \n  \n    \n      1번 손님\n      A, B, C, F, G\n    \n    \n      2번 손님\n      A, C\n    \n    \n      3번 손님\n      C, D, E\n    \n    \n      4번 손님\n      A, C, D, E\n    \n    \n      5번 손님\n      B, C, F, G\n    \n    \n      6번 손님\n      A, C, D, E, H\n    \n  \n\n\n가장 많이 함께 주문된 단품메뉴 조합에 따라 스카피가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다.\n\n\n  \n    \n      코스 종류\n      메뉴 구성\n      설명\n    \n  \n  \n    \n      요리 2개 코스\n      A, C\n      1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다.\n    \n    \n      요리 3개 코스\n      C, D, E\n      3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다.\n    \n    \n      요리 4개 코스\n      B, C, F, G\n      1번, 5번 손님으로부터 총 2번 주문됐습니다.\n    \n    \n      요리 4개 코스\n      A, C, D, E\n      4번, 6번 손님으로부터 총 2번 주문됐습니다.\n    \n  \n\n\n[문제]\n\n각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, “스카피”가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, “스카피”가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.\n\n[제한사항]\n\n\n  orders 배열의 크기는 2 이상 20 이하입니다.\n  orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다.\n    \n      각 문자열은 알파벳 대문자로만 이루어져 있습니다.\n      각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다.\n    \n  \n  course 배열의 크기는 1 이상 10 이하입니다.\n    \n      course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다.\n      course 배열에는 같은 값이 중복해서 들어있지 않습니다.\n    \n  \n  정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요.\n    \n      배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다.\n      만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다.\n      orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다.\n    \n  \n\n\n[입출력 예]\n\n\n  \n    \n      orders\n      course\n      result\n    \n  \n  \n    \n      [“ABCFG”, “AC”, “CDE”, “ACDE”, “BCFG”, “ACDEH”]\n      [2,3,4]\n      [“AC”, “ACDE”, “BCFG”, “CDE”]\n    \n    \n      [“ABCDE”, “AB”, “CD”, “ADE”, “XYZ”, “XYZ”, “ACD”]\n      [2,3,5]\n      [“ACD”, “AD”, “ADE”, “CD”, “XYZ”]\n    \n    \n      [“XYZ”, “XWY”, “WXA”]\n      [2,3,4]\n      [“WX”, “XY”]\n    \n  \n\n\n\n\nSolution\n\n[문제 이해]\n\n내가 이해한 내용은 다음과 같습니다.\n\n  \n    조합을 사용해야 할 것\n    결과는 가장 큰 데이터 리스트\n  \n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\n# 조합 생성을 위한 라이브러리\nfrom itertools import combinations\n# 문제의 제한사항 해결을 위한 라이브러리\nimport numpy as np\n\ndef solution(orders, course):\n    answer = []\n    # 요리 n개 코스\n    for num in course:\n        menu_count = {}\n        # 주문 목록의 요리로 중복되지 않는 조합을 구성\n        for order in orders:\n            for menu in combinations(order, num):\n                menu = &#39;&#39;.join(sorted(menu))\n                # 주문 횟수 카운트\n                if menu not in menu_count.keys():\n                    menu_count[menu] = 1\n                else:\n                    menu_count[menu] += 1\n\n\t# 요리 주문 횟수 배열 생성\n        arr = np.array(list(menu_count.values()))\n        # max값이 여러개인 경우 &amp;amp; 제한사항 조건 처리\n        best_menu = np.where((arr == arr.max()) &amp;amp; (arr &amp;gt;= 2))[0]\n        if len(best_menu) == 0:\n            break\n        # 주문 횟수가 가장 많은 코스 요리 확인\n        for i in best_menu:\n            answer.append(list(menu_count.keys())[i])\n\n    return sorted(answer)\n\n\n[여담]\n\nitertools의 combinations()함수로 코스 요리 조합을 만들 때와 numpy의 where()함수를 통해 여러개의 max값을 구할 때,\n라이브러리 없이 반복문 사용해 해결을 할까 생각했지만 강력한 라이브러리를 두고 사용하지 않는 것은 바보같다는 생각이 들어서 라이브러리를 최대로 활용했습니다.\n\n하지만 문제를 모두 풀고 난 뒤에 주문 횟수 카운트부분과 여러개의 max값을 구하는 부분을 collections의 Counter().most_common() 함수를 통해 한 번에 해결될 수 있다는 내용을 알게 됐습니다.\n\n역시 인터넷은 넓고, 방법은 많다는 사실을 다시 한 번 느끼게 됐습니다.\n\n[collections 라이브러리와 리스트 컴프리헨션을 활용한 코드]\n\nfrom itertools import combinations\nfrom collections import Counter\n\ndef solution(orders, course):\n    answer = []\n    # 요리 n개 코스\n    for num in course:\n        order_combinations = []\n        # 중복되지 않는 요리 조합을 구성\n        for order in orders:\n            order_combinations += combinations(sorted(order), num)\n\n\t# 주문 횟수 카운트와 여러 max를 구하는 부분\n        best_menu = Counter(order_combinations).most_common()\n        answer += [ menu for menu, count in best_menu if count &amp;gt; 1 and count == best_menu[0][1] ]\n        \n    # 문자열 형태로 출력하기 위한 처리\n    return [ &#39;&#39;.join(menu) for menu in sorted(answer) ]\n\n"
} ,
  
  {
    "title"    : "[자료구조] 큐(Queue)",
    "category" : "",
    "tags"     : " 자료구조",
    "url"      : "/2021/07/13/%ED%81%90-Queue.html",
    "date"     : "July 13, 2021",
    "excerpt"  : "\n\n큐(Queue)란?\n\n컴퓨터의 기본적인 자료구조의 한 가지로, FIFO(First In First Out)구조로 데이터를 저장하는 형식입니다.\n\n\n  스택(Stack)의 LIFO(Last In First Out)와 반대되는 개념\n\n\n[발단]\n\n혼자 작은 규모로 자동투자 프로그램을 개발하던 도중\n\n\n  실시간 데이터 감시\n  타겟 데이터 포착시 매매 요청\n\n\n2가지의 기능을 비동기로 구현해야하는 상황이 생겨서 [그림1]의 signal 부...",
  "content"  : "\n\n큐(Queue)란?\n\n컴퓨터의 기본적인 자료구조의 한 가지로, FIFO(First In First Out)구조로 데이터를 저장하는 형식입니다.\n\n\n  스택(Stack)의 LIFO(Last In First Out)와 반대되는 개념\n\n\n[발단]\n\n혼자 작은 규모로 자동투자 프로그램을 개발하던 도중\n\n\n  실시간 데이터 감시\n  타겟 데이터 포착시 매매 요청\n\n\n2가지의 기능을 비동기로 구현해야하는 상황이 생겨서 [그림1]의 signal 부분을 Queue를 통해 구현했습니다.\n\n[그림1]\n\n\n[예시 코드]\n\nPython에서 Queue를 사용하는 간단한 예제입니다.\n\n예제는 3개의 파일로 구성되어 있습니다.\n\n# test_signal.py\n\nfrom multiprocessing import Process, Queue\nfrom test_agent import Agent\nfrom test_trader import Buy, Sell\n\ndef run():\n    queue = Queue()\n    agent = Agent(queue)\n    scouter_price = Process(target=agent.scouter_price)\n    scouter_price.start()\n\n    while True:\n        if not queue.empty():\n            data = queue.get()\n            # scouter_price에서 얻은 데이터 활용\n            if data[0] == &#39;buy&#39;:\n                Buy(data[1])\n            if data[0] == &#39;sell&#39;:\n                Sell(data[1])\n            if data[0] == -1:\n                print(&#39;종료&#39;)\n                break\n\nif __name__ == &#39;__main__&#39;:\n    run()\n\n\n# test_agent.py\n\nfrom time import sleep\n\nclass Agent():\n    def __init__(self, queue):\n        self.queue = queue\n        \n    def scouter_price(self):\n        count = 0\n        while True:\n            # 감시 메커니즘 ...\n            count += 1\n            sleep(1)\n            print(f&#39;count: {count}&#39;)\n            if count == 3:\n                self.queue.put([&#39;buy&#39;, count])\n            if count == 6:\n                self.queue.put([&#39;sell&#39;, count])\n            if count == 7:\n                self.queue.put([-1])\n                break\n            else:\n                pass\n\n\n# test_trader.py\n\ndef Buy(data):\n\t# 매수 메커니즘 ...\n\tprint(f&#39;{data}로 매수 완료&#39;)\n\ndef Sell(data):\n\t# 매도 메커니즘 ...\n\tprint(f&#39;{data}로 매도 완료&#39;)\n\n\n[실행 결과]\n\n실행 카운트 3일 때 3으로 매수 완료, 6일 때 6으로 매도 완료, 7일 때 종료가 출력되고 모든 프로세스가 종료됩니다.\n\n\n"
} ,
  
  {
    "title"    : "[카카오 코딩 테스트] 신규 아이디 추천",
    "category" : "",
    "tags"     : " 알고리즘 문제",
    "url"      : "/2021/07/10/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EB%AC%B8%EC%A0%9C.html",
    "date"     : "July 10, 2021",
    "excerpt"  : "\n\n2021 KAKAO BLIND RECRUITMENT “신규 아이디 추천” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n[문제 설명]\n\n카카오에 입사한 신입 개발자 네오는 &quot;카카오계정개발팀&quot;에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이...",
  "content"  : "\n\n2021 KAKAO BLIND RECRUITMENT “신규 아이디 추천” 문제를 풀어보았습니다.\n\n\n  여기를 누르면 설명을 건너뛸 수 있습니다.\n\n\n\n\n[문제 설명]\n\n카카오에 입사한 신입 개발자 네오는 &quot;카카오계정개발팀&quot;에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.\n다음은 카카오 아이디의 규칙입니다.\n\n- 아이디의 길이는 3자 이상 15자 이하여야 합니다.\n- 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.\n- 단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.\n\n\n“네오”는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.\n신규 유저가 입력한 아이디가 new_id 라고 한다면,\n\n1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.\n2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\n3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\n4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\n5단계 new_id가 빈 문자열이라면, new_id에 &quot;a&quot;를 대입합니다.\n6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.\n만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.\n7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\n\n\n[문제]\n\n신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, “네오”가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.\n\n[제한사항]\n\n\n  new_id는 길이 1 이상 1,000 이하인 문자열입니다.\n  new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.\n  new_id에 나타날 수 있는 특수문자는 -_.~!@#$%^&amp;amp;*()=+[{]}:?,&amp;lt;&amp;gt;/로 한정됩니다.\n\n\n[입출력 예]\n\n\n  \n    \n      no\n      new_id\n      result\n    \n  \n  \n    \n      예1\n      “…!@BaT#*..y.abcdefghijklm”\n      “bat.y.abcdefghi”\n    \n    \n      예2\n      “z-+.^.”\n      “z–”\n    \n    \n      예3\n      ”=.=”\n      “aaa”\n    \n    \n      예4\n      “123_.def”\n      “123_.def”\n    \n    \n      예5\n      “abcdefghijklmn.p”\n      “abcdefghijklmn”\n    \n  \n\n\n\n\nSolution\n\n[문제 이해]\n\n제가 이해한 내용은 다음과 같습니다.\n\n\n  주어진 조건에 따라 구현하기\n  정규식 활용하기\n\n\n이해한 내용을 바탕으로 코드를 작성했습니다.\n\n[코드]\n\nimport re\n\ndef solution(new_id):\n    # 모두 소문자화\n    st = new_id.lower()\n    # 알파벳과 숫자, -, _, . 을 제외한 문자 제거\n    st = re.sub(&#39;[^a-z0-9\\-_.]&#39;, &#39;&#39;, st)\n    # .이 1개 이상인 경우 . 1개로 치환\n    st = re.sub(&#39;\\.+&#39;, &#39;.&#39;, st)\n    # 시작 or 끝의 . 제거\n    st = re.sub(&#39;^[.]|[.]$&#39;, &#39;&#39;, st)\n    # 문자열의 길이가 0인 경우 a 대입 or 15번째까지 인덱싱\n    st = &#39;a&#39; if len(st) == 0 else st[:15]\n    # 변경된 문자열의 시작 or 끝의 . 제거\n    st = re.sub(&#39;^[.]|[.]$&#39;, &#39;&#39;, st)\n    # 문자열의 최소길이 3자를 맞추기 위한 조건\n    answer = st if len(st) &amp;gt; 2 else st + &quot;&quot;.join([st[-1] for i in range(3-len(st))])\n    return answer\n\n"
} ,
  
  {
    "title"    : "Dark Mode",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/12/dark-mode.html",
    "date"     : "November 12, 2020",
    "excerpt"  : "More colors with less light.\n\nClick the half-moon most top-right button to turn the lights on/off.\n\nHeaders\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\n\nHeaders with links\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\n\nCode highlight\nMode specific code high...",
  "content"  : "More colors with less light.\n\nClick the half-moon most top-right button to turn the lights on/off.\n\nHeaders\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\n\nHeaders with links\nLevel 2\nLevel 3\nLevel 4\nLevel 5\nLevel 6\n\nCode highlight\nMode specific code highlighting themes. Kramdown which is responsible for the color highlighting may be more limited than your IDE.\n\n#!/usr/bin/env python\n&quot;&quot;&quot;\nTest file for syntax\n&quot;&quot;&quot;\n# TODO: Use dark mode\nfrom sys import os\n\ndef foo(bar): \n    try:\n        print(bar)\n    except NameError:\n        print(&quot;Variable bar is not defined&quot;)\n\n\nclass Bar(object): \n    def __init__(self):\n        foo(1)\n        self.octal = &#39;\\04&#39;\n        self.text = &quot;&quot;&quot;Example \\t\\n&quot;&quot;&quot;\n    \n    def __exit__(self, *args):\n        print(&#39;exit\\u1111\\xFF&#39;)\n        pass\n    \n    @staticmethod\n    def example():\n        assert (1.0 and 2L) or True\n        return { &quot;example&quot;: [(1,), (r&#39;raw&#39;, u&#39;unicode&#39;)]}\n\n\nTables\n\n\n  \n    \n      hex\n      dec\n      oct\n    \n  \n  \n    \n      0\n      0\n      0\n    \n    \n      5\n      5\n      5\n    \n    \n      A\n      10\n      12\n    \n    \n      F\n      16\n      20\n    \n    \n      F5\n      21\n      25\n    \n  \n\n\nKaTeX\n\nSome KaTeX diagrams to check in dark mode:\n\n\\[\\begin{CD}\nA @&amp;gt;a&amp;gt;&amp;gt; B \\\\\n@VbVV @AAcA \\\\\nC @= D\n\\end{CD}\\]\n\n\\[\\utilde{AB}\\]\n"
} ,
  
  {
    "title"    : "Sample post",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/11/sample-post.html",
    "date"     : "November 11, 2020",
    "excerpt"  : "Consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. \nPraesent et diam eget libero egestas mattis sit amet vitae augue. Nam tinci...",
  "content"  : "Consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. \nPraesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. \n\nDonec ut libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ut gravida lorem.\n\n\n  Consectetur adipiscing elit\n  Donec a diam lectus\n  Sed sit amet ipsum mauris\n\n\nUt turpis felis, pulvinar a semper sed, adipiscing id dolor. Pellentesque auctor nisi id magna consequat sagittis. Curabitur dapibus enim sit amet elit pharetra tincidunt feugiat nisl imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est.\n\nNunc diam velit, adipiscing ut tristique vitae, sagittis vel odio. Maecenas convallis ullamcorper ultricies. Curabitur ornare, ligula semper consectetur sagittis, nisi diam iaculis velit, id fringilla sem nunc vel mi. Nam dictum, odio nec pretium volutpat, arcu ante placerat erat, non tristique elit urna et turpis. Quisque mi metus, ornare sit amet fermentum et, tincidunt et orci. Fusce eget orci a orci congue vestibulum.\n\n\n    \n    \n        \n    \n    \n\n\nUt dolor diam, elementum et vestibulum eu, porttitor vel elit. Curabitur venenatis pulvinar tellus gravida ornare. Sed et erat faucibus nunc euismod ultricies ut id justo. Nullam cursus suscipit nisi, et ultrices justo sodales nec. Fusce venenatis facilisis lectus ac semper. Aliquam at massa ipsum. Quisque bibendum purus convallis nulla ultrices ultricies. Nullam aliquam, mi eu aliquam tincidunt, purus velit laoreet tortor, viverra pretium nisi quam vitae mi. Fusce vel volutpat elit. Nam sagittis nisi dui.\n\n\n  Suspendisse lectus leo, consectetur in tempor sit amet, placerat quis neque\n\n\nEtiam luctus porttitor lorem, sed suscipit est rutrum non. Curabitur lobortis nisl a enim congue semper. Aenean commodo ultrices imperdiet. Vestibulum ut justo vel sapien venenatis tincidunt.\n\n\\[\\Theta \\ne \\Gamma\\]\n\nPhasellus eget dolor sit amet ipsum dapibus condimentum vitae quis lectus. Aliquam ut massa in turpis dapibus convallis. Praesent elit lacus, vestibulum at malesuada et, ornare et est. Ut augue nunc, sodales ut euismod non, adipiscing vitae orci1. Mauris ut placerat justo. Mauris in ultricies enim. Quisque nec est eleifend nulla ultrices egestas quis ut quam. Donec sollicitudin lectus a mauris pulvinar id aliquam urna cursus. Cras quis ligula sem, vel elementum mi. Phasellus non ullamcorper urna.\n\n\n  \n    \n\n      John Smith, A Title About Citations &amp;#8617;\n    \n  \n\n"
} ,
  
  {
    "title"    : "Color Post",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/10/color-post.html",
    "date"     : "November 10, 2020",
    "excerpt"  : "What a colorful post!\n\nThis is an idea that came from xukimseven/HardCandy-Jekyll \nlooking at this cheerful and colorful theme, I wanted to enable something similar for Type-on-Strap.\n\nYou can go fork and star HardCandy-Jekyll too! 😉\n\n\n\nHow does i...",
  "content"  : "What a colorful post!\n\nThis is an idea that came from xukimseven/HardCandy-Jekyll \nlooking at this cheerful and colorful theme, I wanted to enable something similar for Type-on-Strap.\n\nYou can go fork and star HardCandy-Jekyll too! 😉\n\n\n\nHow does it work?\n\nBasically you need to add just one thing, the color:\n\n---\nlayout: post\ntitle: Color Post\ncolor: brown\n---\n\n\nIt can either be a html color like brown (which look like red to me). Or with the rgb:\n\n---\nlayout: post\ntitle: Color Post\ncolor: rgb(165,42,42)\n---\n\n\nThe background used is lineart.png from xukimseven you can edit it in the config file. \nIf you want another one, put it in /assets/img as well.\n\n\n  ⚠️ It’s a bit hacking the css in the post.html\n\n"
} ,
  
  {
    "title"    : "Bootstrap",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/09/Use-Bootstrap.html",
    "date"     : "November 9, 2020",
    "excerpt"  : "This theme is compatible with Bootstrap if you choose to use it in your pages or posts.\nHere is a little demo with a code snippet, look at the source to see how the HTML and markdown get tangled.\n\nUse bootstrap\n\nAdd some custom Bootstrap in the cu...",
  "content"  : "This theme is compatible with Bootstrap if you choose to use it in your pages or posts.\nHere is a little demo with a code snippet, look at the source to see how the HTML and markdown get tangled.\n\nUse bootstrap\n\nAdd some custom Bootstrap in the custom layout!\n\n\n\nSnippet example\n\nIf you are new to Bootstrap you can  always check the documentation.\nHere is an example from startbootstrap.com.\n\n\n\n\n  \n    \n      \n        \n        \n          \n            Project One\n          \n          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam viverra euismod odio, gravida pellentesque urna varius vitae.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Two\n          \n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fugit aliquam aperiam nulla perferendis dolor nobis numquam, rem expedita, aliquid optio, alias illum eaque. Non magni, voluptates quae, necessitatibus unde temporibus.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Three\n          \n          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam viverra euismod odio, gravida pellentesque urna varius vitae.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Four\n          \n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fugit aliquam aperiam nulla perferendis dolor nobis numquam, rem expedita, aliquid optio, alias illum eaque. Non magni, voluptates quae, necessitatibus unde temporibus.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Five\n          \n          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam viverra euismod odio, gravida pellentesque urna varius vitae.\n        \n      \n    \n    \n      \n        \n        \n          \n            Project Six\n          \n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fugit aliquam aperiam nulla perferendis dolor nobis numquam, rem expedita, aliquid optio, alias illum eaque. Non magni, voluptates quae, necessitatibus unde temporibus.\n        \n      \n    \n  \n  \n\n\n\n\nMix it with Markdown\n\nAll the above was custom HTML with Bootstrap.\nYou can also mix it up with some markdown.\n\nYou can use the bootstrap’s build in javascript API to control your event.\nHere is a code snippet for the documentation:\n\n$(&#39;#myModal&#39;).on(&#39;show.bs.modal&#39;, function (e) {\n    if (!data) return e.preventDefault() // stops modal from being shown\n})\n\n\nThat’s just for demo though, you would need to properly integrate your javascript in your page.\nUsually you would put any custom javascript script in the assets folder under js and reference it in your page from there.\n\nSo try it out using the bootstrap: true flag! 😉\n"
} ,
  
  {
    "title"    : "Feature images",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/08/feature-images.html",
    "date"     : "November 8, 2020",
    "excerpt"  : "Hopefully you will find enough information about how to set images in your blog here.\nThis is an example of a post which includes a feature image specified in the front matter of the post. \nThe feature image spans the full-width of the page, and i...",
  "content"  : "Hopefully you will find enough information about how to set images in your blog here.\nThis is an example of a post which includes a feature image specified in the front matter of the post. \nThe feature image spans the full-width of the page, and is shown with the title on permalink pages:\n\nfeature-img: &quot;assets/img/feature-img/desk-messy.jpeg&quot;\nthumbnail: &quot;assets/img/thumbnails/feature-img/desk-messy.jpeg&quot; \n\n\nYou can also use a thumbnail, a smaller version of the same image to improve loading of the page.\nThe thumbnail will also be used when you share your article on other platform (linkedin, whatsapp, facebook, …).\n\n\n  \n    And now it is working\n  \n\n\nYou can also add images aligned in your post using the aligner include.\nMake sure to separate all of the image path from in a string separated with ,.\nIt by default look into assets/img/ so give the path from there, example:\n\n{% include aligner.html images=&quot;pexels/book-glass.jpeg,triangle.png&quot; %}\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\nHere you have two images side by side, but you can set more and set the amount per columns \n(by specifying the number of columns or let it be automatic using &quot;auto&quot;):\n\n{% include aligner.html images=&quot;portfolio/cabin.png,portfolio/cake.png,portfolio/circus.png&quot; column=3 %}\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\nit also works with only one images, it is made to display it smaller than normally.\nHowever you can just use the Markdown way of doing it to get the image normal sized and centered.\n\n# Markdown way (bigger)\n![Travel]({{ &quot;/assets/img/pexels/computer.jpeg&quot; | relative_url}})\n# Aligner with only One (50% of width)\n{% include aligner.html images=&quot;pexels/computer.jpeg&quot; %}\n\n\n    \n    \n        \n    \n    \n\n\n"
} ,
  
  {
    "title"    : "Markdown and HTML",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/07/markdown-and-html.html",
    "date"     : "November 7, 2020",
    "excerpt"  : "Jekyll supports the use of Markdown with inline HTML tags which makes it easier to quickly write posts with Jekyll, without having to worry too much about text formatting. A sample of the formatting follows.\n\nTitle\n\nSub title\n\nTables have also bee...",
  "content"  : "Jekyll supports the use of Markdown with inline HTML tags which makes it easier to quickly write posts with Jekyll, without having to worry too much about text formatting. A sample of the formatting follows.\n\nTitle\n\nSub title\n\nTables have also been extended from Markdown:\n\n\n  \n    \n      First Header\n      Second Header\n    \n  \n  \n    \n      Content Cell\n      Content Cell\n    \n    \n      Content Cell\n      Content Cell\n    \n  \n\n\nHere’s an example of an image, which is included using Markdown:\n\n\n\nThis is another example of list:\n\n\n  list of things\n    \n      Sub list\n      of Other things\n      with numbers\n    \n  \n  And many more\n    \n      Sub sub list\n        \n          can go on …\n            \n              and on …\n                \n                  and on !\n                \n              \n            \n          \n        \n      \n      That’s it.\n    \n  \n\n\nOther subtitle\n\nHighlighting for code in Jekyll is done using Base16 or Rouge. This theme makes use of Rouge by default.\n\n// count to ten\nfor (var i = 1; i &amp;lt;= 10; i++) {\n    console.log(i);\n}\n\n// count to twenty\nvar j = 0;\nwhile (j &amp;lt; 20) {\n    j++;\n    console.log(j);\n}\n\nMath\n\nType on Strap uses KaTeX to display maths. Equations such as \\(S_n = a \\times \\frac{1-r^n}{1-r}\\) can be displayed inline.\n\nAlternatively, they can be shown on a new line:\n\n\\[f(x) = \\int \\frac{2x^2+4x+6}{x-2}\\]\n\n"
} ,
  
  {
    "title"    : "What&#39;s your title",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/06/whats-your-title.html",
    "date"     : "November 6, 2020",
    "excerpt"  : "This is an example of a post which includes a feature image that has a\ntext, where you don’t want to redisplay the title.\nMind your image size in order for the text to be displayed where you want it to.\nThe only limit is your imagination.\n\nHere is...",
  "content"  : "This is an example of a post which includes a feature image that has a\ntext, where you don’t want to redisplay the title.\nMind your image size in order for the text to be displayed where you want it to.\nThe only limit is your imagination.\n\nHere is how the yaml looks inside the post:\n\ntitle: What&#39;s your title\nhide_title: true\nfeature-img: assets/img/feature-img/story.jpeg\nauthor: mhagnumdw\ntags: [Test, Lorem]\n\n\nYou may wonder, why is there a title when you are not actually displaying it. \nWell that’s due to some jekyll limitation:\n\n\n  You can’t set the title to the empty string\n\n\nThe title is used elsewhere than inside the post, for example in the blog page that list this post.\nAn empty title would break those pages and possibly prevents jekyll to render your blog.\n"
} ,
  
  {
    "title"    : "The Real Lorem Ipsum",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/05/lorem-ipsum.html",
    "date"     : "November 5, 2020",
    "excerpt"  : "Lorem Ipsum\n\nfrom “de Finibus Bonorum et Malorum” written by Cicero in 45 BC.\n \nFind out more on lipsum.com. And if you like colors, check out the http color trends from w3schools.\n\nThe standard Lorem Ipsum passage (since 1500s)\n\n“Lorem ipsum dolo...",
  "content"  : "Lorem Ipsum\n\nfrom “de Finibus Bonorum et Malorum” written by Cicero in 45 BC.\n \nFind out more on lipsum.com. And if you like colors, check out the http color trends from w3schools.\n\nThe standard Lorem Ipsum passage (since 1500s)\n\n“Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.”\n\nSection 1.10.32\n\nLatin\n“Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?”\n\nTranslation by H. Rackham (1914)\n“But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born and I will give you a complete account of the system, and expound the actual teachings of the great explorer of the truth, the master-builder of human happiness. No one rejects, dislikes, or avoids pleasure itself, because it is pleasure, but because those who do not know how to pursue pleasure rationally encounter consequences that are extremely painful. Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, but because occasionally circumstances occur in which toil and pain can procure him some great pleasure. To take a trivial example, which of us ever undertakes laborious physical exercise, except to obtain some advantage from it? But who has any right to find fault with a man who chooses to enjoy a pleasure that has no annoying consequences, or one who avoids a pain that produces no resultant pleasure?”\n\nSection 1.10.33\n\nLatin\n\n“At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga. Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor repellendus. Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat.”\n\nTranslation by H. Rackham (1914)\n\n“On the other hand, we denounce with righteous indignation and dislike men who are so beguiled and demoralized by the charms of pleasure of the moment, so blinded by desire, that they cannot foresee the pain and trouble that are bound to ensue; and equal blame belongs to those who fail in their duty through weakness of will, which is the same as saying through shrinking from toil and pain. These cases are perfectly simple and easy to distinguish. In a free hour, when our power of choice is untrammelled and when nothing prevents our being able to do what we like best, every pleasure is to be welcomed and every pain avoided. But in certain circumstances and owing to the claims of duty or the obligations of business it will frequently occur that pleasures have to be repudiated and annoyances accepted. The wise man therefore always holds in these matters to this principle of selection: he rejects pleasures to secure other greater pleasures, or else he endures pains to avoid worse pains.”\n\n"
} ,
  
  {
    "title"    : "Markup: Syntax Highlighting",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/04/Markup-Syntax-Highlighting.html",
    "date"     : "November 4, 2020",
    "excerpt"  : "Syntax highlighting1 is a feature that displays source code. \nThis feature facilitates writing in a structured language such as a programming language or a markup language as it makes import things visually distinct.\n\nGFM Code Blocks\n\nGitHub Flavo...",
  "content"  : "Syntax highlighting1 is a feature that displays source code. \nThis feature facilitates writing in a structured language such as a programming language or a markup language as it makes import things visually distinct.\n\nGFM Code Blocks\n\nGitHub Flavored Markdown fenced code blocks are supported. To modify styling and highlight colors edit /_sass/syntax.scss.\n\n#container {\n  float: left;\n  margin: 0 -240px 0 0;\n  width: 100%;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n.highlight {\n  margin: 0;\n  padding: 1em;\n  font-family: $monospace;\n  font-size: $type-size-7;\n  line-height: 1.8;\n}\n\n\n&amp;lt;nav class=&quot;pagination&quot; role=&quot;navigation&quot;&amp;gt;\n  {% if page.previous %}\n    &amp;lt;a href=&quot;{{ site.url }}{{ page.previous.url }}&quot; class=&quot;btn&quot; title=&quot;{{ page.previous.title }}&quot;&amp;gt;Previous article&amp;lt;/a&amp;gt;\n  {% endif %}\n  {% if page.next %}\n    &amp;lt;a href=&quot;{{ site.url }}{{ page.next.url }}&quot; class=&quot;btn&quot; title=&quot;{{ page.next.title }}&quot;&amp;gt;Next article&amp;lt;/a&amp;gt;\n  {% endif %}\n&amp;lt;/nav&amp;gt;&amp;lt;!-- /.pagination --&amp;gt;\n\n\nmodule Jekyll\n  class TagIndex &amp;lt; Page\n    def initialize(site, base, dir, tag)\n      @site = site\n      @base = base\n      @dir = dir\n      @name = &#39;index.html&#39;\n      self.process(@name)\n      self.read_yaml(File.join(base, &#39;_layouts&#39;), &#39;tag_index.html&#39;)\n      self.data[&#39;tag&#39;] = tag\n      tag_title_prefix = site.config[&#39;tag_title_prefix&#39;] || &#39;Tagged: &#39;\n      tag_title_suffix = site.config[&#39;tag_title_suffix&#39;] || &#39;&amp;amp;#8211;&#39;\n      self.data[&#39;title&#39;] = &quot;#{tag_title_prefix}#{tag}&quot;\n      self.data[&#39;description&#39;] = &quot;An archive of posts tagged #{tag}.&quot;\n    end\n  end\nend\n\n\nCode Blocks in Lists\n\nIndentation matters. Be sure the indent of the code block aligns with the first non-space character after the list item marker (e.g., 1.). Usually this will mean indenting 3 spaces instead of 4.\n\n\n  Do step 1.\n  \n    Now do this:\n\n    def print_hi(name)\n  puts &quot;Hi, #{name}&quot;\nend\nprint_hi(&#39;Tom&#39;)\n#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.\n    \n  \n  Now you can do this.\n\n\nGitHub Gist Embed\n\nAn example of a Gist embed below:\n\n\n\nYou can use defer=true so that the loading of the gist doesn’t prevent the loading of the page.\n\n   &amp;lt;script defer=true \n           src=&quot;https://gist.github.com/sylhare/dad7ed1ef3d13614c77c4ebadf8a11c3.js&quot;&amp;gt;\n   &amp;lt;/script&amp;gt;\n\n\n  \n    \n\n      Michael’s Rose, Minimal Mistakes &amp;#8617;\n    \n  \n\n"
} ,
  
  {
    "title"    : "Generate a table of content",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/03/Generate-a-table-of-content.html",
    "date"     : "November 3, 2020",
    "excerpt"  : "Using Kramdown GFM \n\n\n\n  Using Kramdown GFM     \n      Basic Usage\n    \n  \n  Using toc.js    \n      Customize with toc.js        \n          Use with this jekyll template\n        \n      \n      Basic Usage\n      How it would look like\n    \n  \n\n\nBasi...",
  "content"  : "Using Kramdown GFM \n\n\n\n  Using Kramdown GFM     \n      Basic Usage\n    \n  \n  Using toc.js    \n      Customize with toc.js        \n          Use with this jekyll template\n        \n      \n      Basic Usage\n      How it would look like\n    \n  \n\n\nBasic Usage\n\nYou need to put this at the beginning of the page where you want the table of content to be displayed\n\n* TOC\n{:toc}\n\n\nIt will then render the markdown and html titles (lines that begins with # or using the &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; tages)\n\nUsing toc.js\n\nDemo display of jekyll-table-of-contents by ghiculescu.\n\n\n\n\nCustomize with toc.js\n\ntoc.js stands for table of content, it is a js plugin that generates automatically a table of content of a post.\n\nUse with this jekyll template\n\nIf you want to customize the theme it is up to you, you can add the toc.js file into the asset &amp;gt; js and add it into the page.html layout with:\n\n&amp;lt;script src=&quot;/assets/js/toc.js&quot; &amp;gt;&amp;lt;/script&amp;gt;\n\nThen you can use it as it is said on the repository.\n\nBasic Usage\n\nThe script requires jQuery. First, reference toc.js in templates where you would like to add the table of content. Then, create an HTML element wherever you want your table of contents to appear:\n\n&amp;lt;div id=&quot;toc&quot;&amp;gt;&amp;lt;/div&amp;gt;\n\n\nThen you put your post with titles and all like:\n\n## Title\n## Mid title 1\nThis is text on page one\n## Mid title 2\nThis is text for page two\n### Sub title 2.a\nSome more text\n\n\nThen at the end of your post, you call the .toc() function using:\n\n&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;\n$(document).ready(function() {\n    $(&#39;#toc&#39;).toc();\n});\n&amp;lt;/script&amp;gt;\n\n\nHow it would look like\n\nSo you can get a feel of it.\n\n\n\n\n\n\n\n\n"
} ,
  
  {
    "title"    : "Tech Stuff example",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/02/Tech-stuff-example.html",
    "date"     : "November 2, 2020",
    "excerpt"  : "Because if you put some code in your blog, you would at least make it:\n\n\n  Searchable\n  Good-looking\n\n\nSearch on code\n\nSearch should be working even for complicated escape symbols.\n\nsed -i &#39;s/\\&quot;hostname\\&quot;\\:.*$/\\&quot;hostname\\&quot;\\: \\&quot;&#39;$IPADDR&#39;\\&quot;\\,/g&#39; ope...",
  "content"  : "Because if you put some code in your blog, you would at least make it:\n\n\n  Searchable\n  Good-looking\n\n\nSearch on code\n\nSearch should be working even for complicated escape symbols.\n\nsed -i &#39;s/\\&quot;hostname\\&quot;\\:.*$/\\&quot;hostname\\&quot;\\: \\&quot;&#39;$IPADDR&#39;\\&quot;\\,/g&#39; open-falcon/agent/config/cfg.json\n\n\nOr try searching for partial of a command, like this article should be returned when looking for “find grep”\n\nfind /etc -type f -exec cat &#39;{}&#39; \\; | tr -c &#39;.[:digit:]&#39; &#39;\\n&#39; | grep &#39;^[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*\\.[^.][^.]*$&#39;\n\n\nCode highlighting examples\n\nBecause you might put code in your blog post, and you want to make sure it will look good in here.\nPlus that the search function will still be working!\n\nJava\n\njava example\n\nimport java.util.*;\n\n@Example\npublic class Demo {\n  private static final String CONSTANT = &quot;String&quot;;\n  private Object o;\n  /**\n   * Creates a new demo.\n   * @param o The object to demonstrate.\n   */\n  public Demo(Object o) {\n    this.o = o;\n    String s = CONSTANT + &quot;Other example of text&quot;;\n    int i = 123 - 33 % 11;\n  }\n  public static void main(String[] args) {\n    Demo demo = new Demo();\n    System.out.println(demo.o.toString())\n  }\n}\n\n\nHTML\n\nhtml example\n\n&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html lang=&quot;en&quot;&amp;gt;\n  &amp;lt;body&amp;gt;\n    &amp;lt;div class=&quot;content&quot;&amp;gt;\n        This is an example\n    &amp;lt;/div&amp;gt;\n  &amp;lt;/body&amp;gt;\n&amp;lt;/html&amp;gt;\n\n\nJavascript\n\n/**\n * Does a thing\n */\nfunction helloWorld(param1, param2) {\n  var something = 0;\n\n  // Do something\n  if (2.0 % 2 == something) {\n    console.log(&#39;Hello, world!&#39;);\n  } else {\n    return null;\n  }\n\n  // @TODO comment\n}\n\n\nPython\n\nimport os\n\ndef some_function(param_one=&quot;&quot;, param_two=0):\n    r&#39;&#39;&#39;A docstring&#39;&#39;&#39;\n    if param_one &amp;gt; param_two: # interesting\n        print(&quot;Greater&quot;)\n    return (param_two - param_one + 1 + 0b10) or None\n\nclass SomeClass:\n    &quot;&quot;&quot; dunno what I am doing &quot;&quot;&quot;\n    \n    def __init__(self):\n        pass\n\n\nYAML\n\nYou can also render some yaml, like this _config.yml:\n\n\n# Welcome to Jekyll!\n#\n# This config file is meant for settings that affect your whole blog, values\n# which you are expected to set up once and rarely edit after that. If you find\n# yourself editing this file very often, consider using Jekyll&#39;s data files\n# feature for the data you need to update frequently.\n#\n# This file, &quot;_config.yml&quot; is *NOT* reloaded automatically when you use\n# &#39;bundle exec jekyll serve&#39;. If you change this file, please restart the server process.\n\n# Site settings\n# These are used to personalize your new site. If you look in the HTML files,\n# you will see them accessed via Jeon Repository, , and so on.\n# You can create any custom variable you would like, and they will be accessible\n# in the templates via .\n\n# SITE CONFIGURATION\nbaseurl: &quot;/Type-on-Strap&quot;\nurl: &quot;https://sylhare.github.io&quot;\n\n# THEME-SPECIFIC CONFIGURATION\ntitle: Type on Strap                                    # site&#39;s title\ndescription: &quot;A website with blog posts and pages&quot;      # used by search engines\navatar: assets/img/triangle.png                         # Empty for no avatar in navbar\nfavicon: assets/favicon.ico                             # Icon displayed in the tab\n\nremote_theme: sylhare/Type-on-Strap                     # If using as a remote_theme in github\n\n\nMermaid\n\nDiagrams with mermaid.\n\nHere is a simple example using:\n\n&amp;lt;div class=&quot;mermaid&quot;&amp;gt;\nsequenceDiagram\n    Alice-&amp;gt;&amp;gt;John: Hello John, how are you?\n    John--&amp;gt;&amp;gt;Alice: Great!\n&amp;lt;/div&amp;gt;\n\n\nThat will be rendered into this:\n\n\n    \n    \n        \n    \n    \n\n\nYou can also go with more complex features and diagrams from the documentation:\n\n\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice-&amp;gt;&amp;gt;John: Hello John, how are you?\n    loop Healthcheck\n        John-&amp;gt;&amp;gt;John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts prevail!\n    John--&amp;gt;&amp;gt;Alice: Great!\n    John-&amp;gt;&amp;gt;Bob: How about you?\n    Bob--&amp;gt;&amp;gt;John: Jolly good!\n\n"
} ,
  
  {
    "title"    : "Blogging with title ",
    "category" : "",
    "tags"     : " ",
    "url"      : "/2020/11/01/blogging-with-title.html",
    "date"     : "November 1, 2020",
    "excerpt"  : "I am a BIG title\n\nThis is a very tiny tiny post with less than 250 letters.\n\n",
  "content"  : "I am a BIG title\n\nThis is a very tiny tiny post with less than 250 letters.\n\n"
} 
  
  ,
  
  {
  
  "title"    : "Remote Updater",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/remote-updater",
  "date"     : "July 28, 2021",
  "excerpt"  : "\n\n\n\n이 프로젝트에서 습득한 Tech Skill\n\n\n  html, css 기초 문법\n\n\n개발 환경\n\n\n  Python 3.9.0\n  Flask 2.0.1\n  Duck DNS\n\n\n목적\n\ngithub 1일 1커밋을 지켜보기 위해서 파일 업로드, shell 명령어 실행의 목적으로 개발을 진행\n\n설명\n\n\n  간단하게 파일 업로드, shell 명령어 실행의 목적으로 만든 만큼 단순한 서버의 형태\n  특정 기기를 제외한 외부의 접근을 배제\n\n\nGi...",
  "content"  : "\n\n\n\n이 프로젝트에서 습득한 Tech Skill\n\n\n  html, css 기초 문법\n\n\n개발 환경\n\n\n  Python 3.9.0\n  Flask 2.0.1\n  Duck DNS\n\n\n목적\n\ngithub 1일 1커밋을 지켜보기 위해서 파일 업로드, shell 명령어 실행의 목적으로 개발을 진행\n\n설명\n\n\n  간단하게 파일 업로드, shell 명령어 실행의 목적으로 만든 만큼 단순한 서버의 형태\n  특정 기기를 제외한 외부의 접근을 배제\n\n\nGithub\n\nRemote-Updater\n"
  
} 
  
]
