---
layout: post
title: "[카카오 코딩 테스트] 합승 택시 요금"
author: janos
tags: [알고리즘 문제]
---

---

2021 KAKAO BLIND RECRUITMENT "합승 택시 요금" 문제를 풀어보았습니다.

> [여기](#solution)를 누르면 설명을 건너뛸 수 있습니다.

---

### **문제 설명**

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던 `무지`는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. "무지"는 자신이 택시를 이용할 때 동료인 `어피치` 역시 자신과 비슷한 방향으로 가는 택시를 종종 이용하는 것을 알게 되었습니다. "무지"는 "어피치"와 귀가 방향이 비슷하여 택시 합승을 적절히 이용하면 택시요금을 얼마나 아낄 수 있을 지 계산해 보고 "어피치"에게 합승을 제안해 보려고 합니다.

![Result]({{ "/assets/img/post/2021-07-24-카카오-코딩테스트-합승-택시-요금/합승-택시-문제.png" | relative_url }})

위 예시 그림은 택시가 이동 가능한 반경에 있는 6개 지점 사이의 이동 가능한 택시노선과 예상요금을 보여주고 있습니다.그림에서 `A`와 `B` 두 사람은 출발지점인 4번 지점에서 출발해서 택시를 타고 귀가하려고 합니다. `A`의 집은 6번 지점에 있으며 `B`의 집은 2번 지점에 있고 두 사람이 모두 귀가하는 데 소요되는 예상 최저 택시요금이 얼마인 지 계산하려고 합니다.

- 그림의 원은 지점을 나타내며 원 안의 숫자는 지점 번호를 나타냅니다.
    - 지점이 n개일 때, 지점 번호는 1부터 n까지 사용됩니다.
- 지점 간에 택시가 이동할 수 있는 경로를 간선이라 하며, 간선에 표시된 숫자는 두 지점 사이의 예상 택시요금을 나타냅니다.
    - 간선은 편의 상 직선으로 표시되어 있습니다.
    - 위 그림 예시에서, 4번 지점에서 1번 지점으로(4→1) 가거나, 1번 지점에서 4번 지점으로(1→4) 갈 때 예상 택시요금은 `10`원으로 동일하며 이동 방향에 따라 달라지지 않습니다.
- 예상되는 최저 택시요금은 다음과 같이 계산됩니다.
    - 4→1→5 : `A`, `B`가 합승하여 택시를 이용합니다. 예상 택시요금은 `10 + 24 = 34`원 입니다.
    - 5→6 : `A`가 혼자 택시를 이용합니다. 예상 택시요금은 `2`원 입니다.
    - 5→3→2 : `B`가 혼자 택시를 이용합니다. 예상 택시요금은 `24 + 22 = 46`원 입니다.
    - `A`, `B` 모두 귀가 완료까지 예상되는 최저 택시요금은 `34 + 2 + 46 = 82`원 입니다.

### **[문제]**

지점의 개수 n, 출발지점을 나타내는 s, `A`의 도착지점을 나타내는 a, `B`의 도착지점을 나타내는 b, 지점 사이의 예상 택시요금을 나타내는 fares가 매개변수로 주어집니다. 이때, `A`, `B` 두 사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 간다고 가정할 때, 최저 예상 택시요금을 계산해서 return 하도록 solution 함수를 완성해 주세요.만약, 아예 합승을 하지 않고 각자 이동하는 경우의 예상 택시요금이 더 낮다면, 합승을 하지 않아도 됩니다.

### **[제한사항]**

- 지점갯수 n은 3 이상 200 이하인 자연수입니다.
- 지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.
    - 즉, 출발지점, `A`의 도착지점, `B`의 도착지점은 서로 겹치지 않습니다.
- fares는 2차원 정수 배열입니다.
- fares 배열의 크기는 2 이상 `n x (n-1) / 2` 이하입니다.
    - 예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (`6 x 5 / 2 = 15`)
    - fares 배열의 각 행은 [c, d, f] 형태입니다.
    - c지점과 d지점 사이의 예상 택시요금이 `f`원이라는 뜻입니다.
    - 지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.
    - 요금 f는 1 이상 100,000 이하인 자연수입니다.
    - fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다.
- 출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다.

### [입출력 예]

n | s | a | b | fares | result
----- | ----- | ----- | ----- | ----- | -----
6 | 4 | 6 | 2 | [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]] | 82
7 | 3 | 4 | 1 | [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]] | 14
6 | 4 | 5 | 6 | [[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]] | 18

---

# Solution

### [문제 이해]

- 이번 문제는 저번에 당했던 효율성 별도 체크 항목 때문에 고민을 좀 더 하면서 풀었습니다.
- 최단 거리 알고리즘(Dijkstra), 우선 탐색 알고리즘(BFS, DFS) 등을 과거에 공부했지만 갑자기 다시 적용을 해보려니까 생각이 잘 나지 않았습니다. → 반복 학습의 필요성을 느낌
- 효율성을 위해 우선순위 큐를 사용해야 한다고 생각이 들었습니다.
→ 우선순위 큐는 힙큐로 구현 가능
- 그래프 구조를 먼저 만들고, 연산을 진행해야 한다고 생각이 들었습니다.

> - 그래프 생성
- 최단 거리 알고리즘 사용 → `다익스트라(Dijkstra)`
- 결과는 노드 이동 거리의 가장 작은 합

이해한 내용을 바탕으로 코드를 작성했습니다.

### [코드]

```python
# 활용성을 위한 힙큐 라이브러리
import heapq

def solution(n, s, a, b, fares):
    # 마지막에 크기 비교를 위해 무한대의 값으로 정의
    answer = float('inf')
    # 입력된 노드의 갯수인 n를 이용해 그래프 구조 생성
    graph = {i+1: {} for i in range(n)}

    # 그래프 내용 채우기
    for x, y, z in fares:
        graph[x][y] = z
        graph[y][x] = z

    # 다익스트라 알고리즘
    def dijkstra(start):
        # 최단 거리를 담기 위한 리스트 배열 생성,
        # 값 비교를 위해 요소값을 무한대로 정의
        distances = [float('inf') for _ in range(n+1)]
        # 시작 노드의 거리는 0으로 지정
        distances[start] = 0
        queue = []
        heapq.heappush(queue, [start, 0])

        while queue:
            # 큐에서 노드와 해당 노드의 거리를 get
            cur_node, cur_distance = heapq.heappop(queue)

            # 현재 거리가 최단 거리보다 크면 반복문 실행 안함
            if distances[cur_node] < cur_distance:
                continue

            # 그래프에서 현재 노드와 연결되어 있는 노드들을 호출하여 거리값 계산
            for next_node, next_distance in graph[cur_node].items():
                distance = cur_distance + next_distance
                # 계산된 거리가 리스트 배열의 거리보다 작은 경우
                # 리스트 배열에 계산된 거리를 담고,
                # 힙큐에 해당 노드 추가
                if distance < distances[next_node]:
                    distances[next_node] = distance
                    heapq.heappush(queue, [next_node, distance])

				# distances -> 최단 거리를 담은 리스트 배열
        return distances

		# 2차원 배열의 형태로 노드별 최단 거리를 생성
    d = [dijkstra(i) for i in range(1, n+1)]

    # 합산 거리중 최단 거리를 반환
    for i in range(n):
        answer = min(answer, d[i][s] + d[i][a] + d[i][b])

    return answer
```

### [여담]

점점 문제의 의도를 파악하는 시간이 줄어들고 있어서 문제풀이 행위에 대해서 자체적인 만족을 느꼈습니다.

이번 문제는 `다익스트라(Dijkstra)` 뿐만 아니라 `플로이드 와샬(Floyd Warshall)` 알고리즘 풀이도 가능했습니다.

아래는 `플로이드 와샬(Floyd Warshall)` 알고리즘으로 풀이한 코드입니다.

```python
import heapq

def solution(n, s, a, b, fares):
    d = [ [ 20000001 for _ in range(n) ] for _ in range(n) ]
    for x in range(n):
        d[x][x] = 0
    for x, y, c in fares:
        d[x-1][y-1] = c
        d[y-1][x-1] = c

    # k라는 경로를 거쳐가며 계산을 한다.
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if d[j][k] > d[j][i] + d[i][k]:
                    d[j][k] = d[j][i] + d[i][k]

    minv = 40000002
    for i in range(n):
        minv = min(minv, d[s-1][i]+d[i][a-1]+d[i][b-1])
    return minv
```